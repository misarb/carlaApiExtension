{
    "version": "0.9.14",
    "classes": {
        "AckermannControllerSettings": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "accel_kd": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "accel_ki": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "accel_kp": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "speed_kd": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "speed_ki": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "speed_kp": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "Actor": {
            "type": "class",
            "docstring": "",
            "methods": {
                "add_angular_impulse": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_angular_impulse( (Actor)arg1, (Vector3D)angular_impulse) -> None :\n\n    C++ signature :\n        void add_angular_impulse(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_force": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_force( (Actor)arg1, (Vector3D)force) -> None :\n\n    C++ signature :\n        void add_force(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_impulse": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_impulse( (Actor)arg1, (Vector3D)impulse) -> None :\n\n    C++ signature :\n        void add_impulse(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_torque": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_torque( (Actor)arg1, (Vector3D)torque) -> None :\n\n    C++ signature :\n        void add_torque(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "destroy": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "destroy( (Actor)arg1) -> bool :\n\n    C++ signature :\n        bool destroy(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "disable_constant_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "disable_constant_velocity( (Actor)arg1) -> None :\n\n    C++ signature :\n        void disable_constant_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "enable_constant_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "enable_constant_velocity( (Actor)arg1, (Vector3D)velocity) -> None :\n\n    C++ signature :\n        void enable_constant_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_acceleration": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_acceleration( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_acceleration(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_angular_velocity( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_angular_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_location( (Actor)arg1) -> Location :\n\n    C++ signature :\n        carla::geom::Location get_location(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_transform( (Actor)arg1) -> Transform :\n\n    C++ signature :\n        carla::geom::Transform get_transform(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_velocity( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_world": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_world( (Actor)arg1) -> World :\n\n    C++ signature :\n        carla::client::World get_world(carla::client::Actor)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_enable_gravity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_enable_gravity( (Actor)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void set_enable_gravity(carla::client::Actor {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_location( (Actor)arg1, (Location)location) -> None :\n\n    C++ signature :\n        void set_location(carla::client::Actor {lvalue},carla::geom::Location)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_simulate_physics": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_simulate_physics( (Actor)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void set_simulate_physics(carla::client::Actor {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_target_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_target_angular_velocity( (Actor)arg1, (Vector3D)angular_velocity) -> None :\n\n    C++ signature :\n        void set_target_angular_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_target_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_target_velocity( (Actor)arg1, (Vector3D)velocity) -> None :\n\n    C++ signature :\n        void set_target_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_transform( (Actor)arg1, (Transform)transform) -> None :\n\n    C++ signature :\n        void set_transform(carla::client::Actor {lvalue},carla::geom::Transform)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "actor_state": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "attributes": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "bounding_box": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_active": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_alive": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_dormant": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "parent": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "semantic_tags": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "type_id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "ActorAttribute": {
            "type": "class",
            "docstring": "",
            "methods": {
                "as_bool": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "as_bool( (ActorAttribute)arg1) -> bool :\n\n    C++ signature :\n        bool as_bool(carla::client::ActorAttribute {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "as_color": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "as_color( (ActorAttribute)arg1) -> Color :\n\n    C++ signature :\n        carla::sensor::data::Color as_color(carla::client::ActorAttribute {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "as_float": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "as_float( (ActorAttribute)arg1) -> float :\n\n    C++ signature :\n        float as_float(carla::client::ActorAttribute {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "as_int": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "as_int( (ActorAttribute)arg1) -> int :\n\n    C++ signature :\n        int as_int(carla::client::ActorAttribute {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "as_str": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "as_str( (ActorAttribute)arg1) -> str :\n\n    C++ signature :\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > as_str(carla::client::ActorAttribute {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_modifiable": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "recommended_values": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "type": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "ActorAttributeType": {
            "type": "class",
            "docstring": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "methods": {
                "bit_length": {
                    "type": "method",
                    "signature": "(self, /)",
                    "docstring": "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "conjugate": {
                    "type": "method",
                    "signature": "",
                    "docstring": "Returns self, the complex conjugate of any int.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "from_bytes": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_bytes": {
                    "type": "method",
                    "signature": "(self, /, length, byteorder, *, signed=False)",
                    "docstring": "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {
                "Bool": {
                    "type": "ActorAttributeType",
                    "value": "Bool"
                },
                "Float": {
                    "type": "ActorAttributeType",
                    "value": "Float"
                },
                "Int": {
                    "type": "ActorAttributeType",
                    "value": "Int"
                },
                "RGBColor": {
                    "type": "ActorAttributeType",
                    "value": "RGBColor"
                },
                "String": {
                    "type": "ActorAttributeType",
                    "value": "String"
                },
                "denominator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'denominator' of 'int' objects>"
                },
                "imag": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'imag' of 'int' objects>"
                },
                "name": {
                    "type": "member_descriptor",
                    "value": "<member 'name' of 'Boost.Python.enum' objects>"
                },
                "names": {
                    "type": "dict",
                    "value": "{'Bool': carla.libcarla.ActorAttributeType.Bool, 'Int': carla.libcarla.ActorAttributeType.Int, 'Float': carla.libcarla.ActorAttributeType.Float, 'String': carla.libcarla.ActorAttributeType.String, 'RGBColor': carla.libcarla.ActorAttributeType.RGBColor}"
                },
                "numerator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'numerator' of 'int' objects>"
                },
                "real": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'real' of 'int' objects>"
                },
                "values": {
                    "type": "dict",
                    "value": "{0: carla.libcarla.ActorAttributeType.Bool, 1: carla.libcarla.ActorAttributeType.Int, 2: carla.libcarla.ActorAttributeType.Float, 3: carla.libcarla.ActorAttributeType.String, 4: carla.libcarla.ActorAttributeType.RGBColor}"
                }
            },
            "base_classes": [
                "enum"
            ],
            "source_file": "built-in"
        },
        "ActorBlueprint": {
            "type": "class",
            "docstring": "",
            "methods": {
                "get_attribute": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_attribute( (ActorBlueprint)arg1, (str)arg2) -> ActorAttribute :\n\n    C++ signature :\n        carla::client::ActorAttribute get_attribute(carla::client::ActorBlueprint,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "has_attribute": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "has_attribute( (ActorBlueprint)arg1, (str)arg2) -> bool :\n\n    C++ signature :\n        bool has_attribute(carla::client::ActorBlueprint {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "has_tag": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "has_tag( (ActorBlueprint)arg1, (str)arg2) -> bool :\n\n    C++ signature :\n        bool has_tag(carla::client::ActorBlueprint {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "match_tags": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "match_tags( (ActorBlueprint)arg1, (str)arg2) -> bool :\n\n    C++ signature :\n        bool match_tags(carla::client::ActorBlueprint {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_attribute": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_attribute( (ActorBlueprint)arg1, (str)arg2, (str)arg3) -> None :\n\n    C++ signature :\n        void set_attribute(carla::client::ActorBlueprint {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "tags": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "ActorList": {
            "type": "class",
            "docstring": "",
            "methods": {
                "filter": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "filter( (ActorList)arg1, (str)wildcard_pattern) -> ActorList :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::ActorList> filter(carla::client::ActorList {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "find": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "find( (ActorList)arg1, (int)id) -> Actor :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::Actor> find(carla::client::ActorList {lvalue},unsigned int)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "ActorSnapshot": {
            "type": "class",
            "docstring": "",
            "methods": {
                "get_acceleration": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_acceleration( (ActorSnapshot)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_acceleration(carla::client::ActorSnapshot)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_angular_velocity( (ActorSnapshot)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_angular_velocity(carla::client::ActorSnapshot)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_transform( (ActorSnapshot)arg1) -> Transform :\n\n    C++ signature :\n        carla::geom::Transform get_transform(carla::client::ActorSnapshot)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_velocity( (ActorSnapshot)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_velocity(carla::client::ActorSnapshot)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "ActorState": {
            "type": "class",
            "docstring": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "methods": {
                "bit_length": {
                    "type": "method",
                    "signature": "(self, /)",
                    "docstring": "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "conjugate": {
                    "type": "method",
                    "signature": "",
                    "docstring": "Returns self, the complex conjugate of any int.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "from_bytes": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_bytes": {
                    "type": "method",
                    "signature": "(self, /, length, byteorder, *, signed=False)",
                    "docstring": "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {
                "Active": {
                    "type": "ActorState",
                    "value": "Active"
                },
                "Dormant": {
                    "type": "ActorState",
                    "value": "Dormant"
                },
                "Invalid": {
                    "type": "ActorState",
                    "value": "Invalid"
                },
                "denominator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'denominator' of 'int' objects>"
                },
                "imag": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'imag' of 'int' objects>"
                },
                "name": {
                    "type": "member_descriptor",
                    "value": "<member 'name' of 'Boost.Python.enum' objects>"
                },
                "names": {
                    "type": "dict",
                    "value": "{'Invalid': carla.libcarla.ActorState.Invalid, 'Active': carla.libcarla.ActorState.Active, 'Dormant': carla.libcarla.ActorState.Dormant}"
                },
                "numerator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'numerator' of 'int' objects>"
                },
                "real": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'real' of 'int' objects>"
                },
                "values": {
                    "type": "dict",
                    "value": "{0: carla.libcarla.ActorState.Invalid, 1: carla.libcarla.ActorState.Active, 2: carla.libcarla.ActorState.Dormant}"
                }
            },
            "base_classes": [
                "enum"
            ],
            "source_file": "built-in"
        },
        "AttachmentType": {
            "type": "class",
            "docstring": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "methods": {
                "bit_length": {
                    "type": "method",
                    "signature": "(self, /)",
                    "docstring": "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "conjugate": {
                    "type": "method",
                    "signature": "",
                    "docstring": "Returns self, the complex conjugate of any int.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "from_bytes": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_bytes": {
                    "type": "method",
                    "signature": "(self, /, length, byteorder, *, signed=False)",
                    "docstring": "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {
                "Rigid": {
                    "type": "AttachmentType",
                    "value": "Rigid"
                },
                "SpringArm": {
                    "type": "AttachmentType",
                    "value": "SpringArm"
                },
                "SpringArmGhost": {
                    "type": "AttachmentType",
                    "value": "SpringArmGhost"
                },
                "denominator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'denominator' of 'int' objects>"
                },
                "imag": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'imag' of 'int' objects>"
                },
                "name": {
                    "type": "member_descriptor",
                    "value": "<member 'name' of 'Boost.Python.enum' objects>"
                },
                "names": {
                    "type": "dict",
                    "value": "{'Rigid': carla.libcarla.AttachmentType.Rigid, 'SpringArm': carla.libcarla.AttachmentType.SpringArm, 'SpringArmGhost': carla.libcarla.AttachmentType.SpringArmGhost}"
                },
                "numerator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'numerator' of 'int' objects>"
                },
                "real": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'real' of 'int' objects>"
                },
                "values": {
                    "type": "dict",
                    "value": "{0: carla.libcarla.AttachmentType.Rigid, 1: carla.libcarla.AttachmentType.SpringArm, 2: carla.libcarla.AttachmentType.SpringArmGhost}"
                }
            },
            "base_classes": [
                "enum"
            ],
            "source_file": "built-in"
        },
        "BlueprintLibrary": {
            "type": "class",
            "docstring": "",
            "methods": {
                "filter": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "filter( (BlueprintLibrary)arg1, (str)wildcard_pattern) -> BlueprintLibrary :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::BlueprintLibrary> filter(carla::client::BlueprintLibrary {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "find": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "find( (BlueprintLibrary)arg1, (str)id) -> ActorBlueprint :\n\n    C++ signature :\n        carla::client::ActorBlueprint find(carla::client::BlueprintLibrary,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "BoundingBox": {
            "type": "class",
            "docstring": "",
            "methods": {
                "contains": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "contains( (BoundingBox)arg1, (Location)arg2, (Transform)point) -> bool :\n\n    C++ signature :\n        bool contains(carla::geom::BoundingBox {lvalue},carla::geom::Location,carla::geom::Transform)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_local_vertices": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_local_vertices( (BoundingBox)arg1) -> list :\n\n    C++ signature :\n        boost::python::list get_local_vertices(carla::geom::BoundingBox)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_world_vertices": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_world_vertices( (BoundingBox)arg1, (Transform)bbox_transform) -> list :\n\n    C++ signature :\n        boost::python::list get_world_vertices(carla::geom::BoundingBox,carla::geom::Transform)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "extent": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "location": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "rotation": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "CityObjectLabel": {
            "type": "class",
            "docstring": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "methods": {
                "bit_length": {
                    "type": "method",
                    "signature": "(self, /)",
                    "docstring": "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "conjugate": {
                    "type": "method",
                    "signature": "",
                    "docstring": "Returns self, the complex conjugate of any int.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "from_bytes": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_bytes": {
                    "type": "method",
                    "signature": "(self, /, length, byteorder, *, signed=False)",
                    "docstring": "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {
                "Any": {
                    "type": "CityObjectLabel",
                    "value": "Any"
                },
                "Bicycle": {
                    "type": "CityObjectLabel",
                    "value": "Bicycle"
                },
                "Bridge": {
                    "type": "CityObjectLabel",
                    "value": "Bridge"
                },
                "Buildings": {
                    "type": "CityObjectLabel",
                    "value": "Buildings"
                },
                "Bus": {
                    "type": "CityObjectLabel",
                    "value": "Bus"
                },
                "Car": {
                    "type": "CityObjectLabel",
                    "value": "Car"
                },
                "Dynamic": {
                    "type": "CityObjectLabel",
                    "value": "Dynamic"
                },
                "Fences": {
                    "type": "CityObjectLabel",
                    "value": "Fences"
                },
                "Ground": {
                    "type": "CityObjectLabel",
                    "value": "Ground"
                },
                "GuardRail": {
                    "type": "CityObjectLabel",
                    "value": "GuardRail"
                },
                "Motorcycle": {
                    "type": "CityObjectLabel",
                    "value": "Motorcycle"
                },
                "NONE": {
                    "type": "CityObjectLabel",
                    "value": "NONE"
                },
                "Other": {
                    "type": "CityObjectLabel",
                    "value": "Other"
                },
                "Pedestrians": {
                    "type": "CityObjectLabel",
                    "value": "Pedestrians"
                },
                "Poles": {
                    "type": "CityObjectLabel",
                    "value": "Poles"
                },
                "RailTrack": {
                    "type": "CityObjectLabel",
                    "value": "RailTrack"
                },
                "Rider": {
                    "type": "CityObjectLabel",
                    "value": "Rider"
                },
                "RoadLines": {
                    "type": "CityObjectLabel",
                    "value": "RoadLines"
                },
                "Roads": {
                    "type": "CityObjectLabel",
                    "value": "Roads"
                },
                "Sidewalks": {
                    "type": "CityObjectLabel",
                    "value": "Sidewalks"
                },
                "Sky": {
                    "type": "CityObjectLabel",
                    "value": "Sky"
                },
                "Static": {
                    "type": "CityObjectLabel",
                    "value": "Static"
                },
                "Terrain": {
                    "type": "CityObjectLabel",
                    "value": "Terrain"
                },
                "TrafficLight": {
                    "type": "CityObjectLabel",
                    "value": "TrafficLight"
                },
                "TrafficSigns": {
                    "type": "CityObjectLabel",
                    "value": "TrafficSigns"
                },
                "Train": {
                    "type": "CityObjectLabel",
                    "value": "Train"
                },
                "Truck": {
                    "type": "CityObjectLabel",
                    "value": "Truck"
                },
                "Vegetation": {
                    "type": "CityObjectLabel",
                    "value": "Vegetation"
                },
                "Walls": {
                    "type": "CityObjectLabel",
                    "value": "Walls"
                },
                "Water": {
                    "type": "CityObjectLabel",
                    "value": "Water"
                },
                "denominator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'denominator' of 'int' objects>"
                },
                "imag": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'imag' of 'int' objects>"
                },
                "name": {
                    "type": "member_descriptor",
                    "value": "<member 'name' of 'Boost.Python.enum' objects>"
                },
                "names": {
                    "type": "dict",
                    "value": "{'NONE': carla.libcarla.CityObjectLabel.NONE, 'Buildings': carla.libcarla.CityObjectLabel.Buildings, 'Fences': carla.libcarla.CityObjectLabel.Fences, 'Other': carla.libcarla.CityObjectLabel.Other, 'Pedestrians': carla.libcarla.CityObjectLabel.Pedestrians, 'Poles': carla.libcarla.CityObjectLabel.Poles, 'RoadLines': carla.libcarla.CityObjectLabel.RoadLines, 'Roads': carla.libcarla.CityObjectLabel.Roads, 'Sidewalks': carla.libcarla.CityObjectLabel.Sidewalks, 'TrafficSigns': carla.libcarla.CityObjectLabel.TrafficSigns, 'Vegetation': carla.libcarla.CityObjectLabel.Vegetation, 'Car': carla.libcarla.CityObjectLabel.Car, 'Walls': carla.libcarla.CityObjectLabel.Walls, 'Sky': carla.libcarla.CityObjectLabel.Sky, 'Ground': carla.libcarla.CityObjectLabel.Ground, 'Bridge': carla.libcarla.CityObjectLabel.Bridge, 'RailTrack': carla.libcarla.CityObjectLabel.RailTrack, 'GuardRail': carla.libcarla.CityObjectLabel.GuardRail, 'TrafficLight': carla.libcarla.CityObjectLabel.TrafficLight, 'Static': carla.libcarla.CityObjectLabel.Static, 'Dynamic': carla.libcarla.CityObjectLabel.Dynamic, 'Water': carla.libcarla.CityObjectLabel.Water, 'Terrain': carla.libcarla.CityObjectLabel.Terrain, 'Truck': carla.libcarla.CityObjectLabel.Truck, 'Motorcycle': carla.libcarla.CityObjectLabel.Motorcycle, 'Bicycle': carla.libcarla.CityObjectLabel.Bicycle, 'Bus': carla.libcarla.CityObjectLabel.Bus, 'Rider': carla.libcarla.CityObjectLabel.Rider, 'Train': carla.libcarla.CityObjectLabel.Train, 'Any': carla.libcarla.CityObjectLabel.Any}"
                },
                "numerator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'numerator' of 'int' objects>"
                },
                "real": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'real' of 'int' objects>"
                },
                "values": {
                    "type": "dict",
                    "value": "{0: carla.libcarla.CityObjectLabel.NONE, 3: carla.libcarla.CityObjectLabel.Buildings, 5: carla.libcarla.CityObjectLabel.Fences, 22: carla.libcarla.CityObjectLabel.Other, 12: carla.libcarla.CityObjectLabel.Pedestrians, 6: carla.libcarla.CityObjectLabel.Poles, 24: carla.libcarla.CityObjectLabel.RoadLines, 1: carla.libcarla.CityObjectLabel.Roads, 2: carla.libcarla.CityObjectLabel.Sidewalks, 8: carla.libcarla.CityObjectLabel.TrafficSigns, 9: carla.libcarla.CityObjectLabel.Vegetation, 14: carla.libcarla.CityObjectLabel.Car, 4: carla.libcarla.CityObjectLabel.Walls, 11: carla.libcarla.CityObjectLabel.Sky, 25: carla.libcarla.CityObjectLabel.Ground, 26: carla.libcarla.CityObjectLabel.Bridge, 27: carla.libcarla.CityObjectLabel.RailTrack, 28: carla.libcarla.CityObjectLabel.GuardRail, 7: carla.libcarla.CityObjectLabel.TrafficLight, 20: carla.libcarla.CityObjectLabel.Static, 21: carla.libcarla.CityObjectLabel.Dynamic, 23: carla.libcarla.CityObjectLabel.Water, 10: carla.libcarla.CityObjectLabel.Terrain, 15: carla.libcarla.CityObjectLabel.Truck, 18: carla.libcarla.CityObjectLabel.Motorcycle, 19: carla.libcarla.CityObjectLabel.Bicycle, 16: carla.libcarla.CityObjectLabel.Bus, 13: carla.libcarla.CityObjectLabel.Rider, 17: carla.libcarla.CityObjectLabel.Train, 255: carla.libcarla.CityObjectLabel.Any}"
                }
            },
            "base_classes": [
                "enum"
            ],
            "source_file": "built-in"
        },
        "Client": {
            "type": "class",
            "docstring": "",
            "methods": {
                "apply_batch": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "apply_batch( (Client)arg1, (object)commands [, (bool)do_tick=False]) -> None :\n\n    C++ signature :\n        void apply_batch(carla::client::Client,boost::python::api::object [,bool=False])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "apply_batch_sync": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "apply_batch_sync( (Client)arg1, (object)commands [, (bool)do_tick=False]) -> list :\n\n    C++ signature :\n        boost::python::list apply_batch_sync(carla::client::Client,boost::python::api::object [,bool=False])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "generate_opendrive_world": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "generate_opendrive_world( (Client)arg1, (str)opendrive [, (OpendriveGenerationParameters)parameters=<carla.libcarla.OpendriveGenerationParameters object at 0x72eff395feb0> [, (bool)reset_settings=True]]) -> World :\n\n    C++ signature :\n        carla::client::World generate_opendrive_world(carla::client::Client,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,carla::rpc::OpendriveGenerationParameters=<carla.libcarla.OpendriveGenerationParameters object at 0x72eff395feb0> [,bool=True]])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_available_maps": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_available_maps( (Client)arg1) -> list :\n\n    C++ signature :\n        boost::python::list get_available_maps(carla::client::Client)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_client_version": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_client_version( (Client)arg1) -> str :\n\n    C++ signature :\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > get_client_version(carla::client::Client {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_required_files": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_required_files( (Client)arg1 [, (str)folder='' [, (bool)download=True]]) -> list :\n\n    C++ signature :\n        boost::python::list get_required_files(carla::client::Client [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >='' [,bool=True]])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_server_version": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_server_version( (Client)arg1) -> str :\n\n    C++ signature :\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > get_server_version(carla::client::Client)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_trafficmanager": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_trafficmanager( (Client)arg1 [, (int)port=8000]) -> TrafficManager :\n\n    C++ signature :\n        carla::traffic_manager::TrafficManager get_trafficmanager(carla::client::Client [,unsigned short=8000])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_world": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_world( (Client)arg1) -> World :\n\n    C++ signature :\n        carla::client::World get_world(carla::client::Client {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "load_world": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "load_world( (Client)arg1, (str)map_name [, (bool)reset_settings=True [, (MapLayer)map_layers=carla.libcarla.MapLayer.All]]) -> World :\n\n    C++ signature :\n        carla::client::World load_world(carla::client::Client,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=True [,carla::rpc::MapLayer=carla.libcarla.MapLayer.All]])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "reload_world": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "reload_world( (Client)arg1 [, (bool)reset_settings=True]) -> World :\n\n    C++ signature :\n        carla::client::World reload_world(carla::client::Client [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "replay_file": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "replay_file( (Client)arg1, (str)name, (float)time_start, (float)duration, (int)follow_id [, (bool)replay_sensors=False]) -> str :\n\n    C++ signature :\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > replay_file(carla::client::Client {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,double,double,unsigned int [,bool=False])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "request_file": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "request_file( (Client)arg1, (str)name) -> None :\n\n    C++ signature :\n        void request_file(carla::client::Client {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_files_base_folder": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_files_base_folder( (Client)arg1, (str)path) -> bool :\n\n    C++ signature :\n        bool set_files_base_folder(carla::client::Client {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_replayer_ignore_hero": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_replayer_ignore_hero( (Client)arg1, (bool)ignore_hero) -> None :\n\n    C++ signature :\n        void set_replayer_ignore_hero(carla::client::Client {lvalue},bool)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_replayer_time_factor": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_replayer_time_factor( (Client)arg1, (float)time_factor) -> None :\n\n    C++ signature :\n        void set_replayer_time_factor(carla::client::Client {lvalue},double)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_timeout": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_timeout( (Client)arg1, (float)seconds) -> None :\n\n    C++ signature :\n        void set_timeout(carla::client::Client {lvalue},double)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "show_recorder_actors_blocked": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "show_recorder_actors_blocked( (Client)arg1, (str)name, (float)min_time, (float)min_distance) -> str :\n\n    C++ signature :\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > show_recorder_actors_blocked(carla::client::Client {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,double,double)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "show_recorder_collisions": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "show_recorder_collisions( (Client)arg1, (str)name, (str)type1, (str)type2) -> str :\n\n    C++ signature :\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > show_recorder_collisions(carla::client::Client {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,char,char)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "show_recorder_file_info": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "show_recorder_file_info( (Client)arg1, (str)name, (bool)show_all) -> str :\n\n    C++ signature :\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > show_recorder_file_info(carla::client::Client {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "start_recorder": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "start_recorder( (Client)arg1, (str)name [, (bool)additional_data=False]) -> str :\n\n    C++ signature :\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > start_recorder(carla::client::Client {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=False])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "stop_recorder": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "stop_recorder( (Client)arg1) -> None :\n\n    C++ signature :\n        void stop_recorder(carla::client::Client {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "stop_replayer": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "stop_replayer( (Client)arg1, (bool)keep_actors) -> None :\n\n    C++ signature :\n        void stop_replayer(carla::client::Client {lvalue},bool)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "ClientSideSensor": {
            "type": "class",
            "docstring": "",
            "methods": {
                "add_angular_impulse": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_angular_impulse( (Actor)arg1, (Vector3D)angular_impulse) -> None :\n\n    C++ signature :\n        void add_angular_impulse(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_force": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_force( (Actor)arg1, (Vector3D)force) -> None :\n\n    C++ signature :\n        void add_force(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_impulse": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_impulse( (Actor)arg1, (Vector3D)impulse) -> None :\n\n    C++ signature :\n        void add_impulse(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_torque": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_torque( (Actor)arg1, (Vector3D)torque) -> None :\n\n    C++ signature :\n        void add_torque(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "destroy": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "destroy( (Actor)arg1) -> bool :\n\n    C++ signature :\n        bool destroy(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "disable_constant_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "disable_constant_velocity( (Actor)arg1) -> None :\n\n    C++ signature :\n        void disable_constant_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "enable_constant_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "enable_constant_velocity( (Actor)arg1, (Vector3D)velocity) -> None :\n\n    C++ signature :\n        void enable_constant_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_acceleration": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_acceleration( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_acceleration(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_angular_velocity( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_angular_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_location( (Actor)arg1) -> Location :\n\n    C++ signature :\n        carla::geom::Location get_location(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_transform( (Actor)arg1) -> Transform :\n\n    C++ signature :\n        carla::geom::Transform get_transform(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_velocity( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_world": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_world( (Actor)arg1) -> World :\n\n    C++ signature :\n        carla::client::World get_world(carla::client::Actor)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "is_listening": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "is_listening( (Sensor)arg1) -> bool :\n\n    C++ signature :\n        bool is_listening(carla::client::Sensor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "listen": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "listen( (Sensor)arg1, (object)callback) -> None :\n\n    C++ signature :\n        void listen(carla::client::Sensor {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_enable_gravity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_enable_gravity( (Actor)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void set_enable_gravity(carla::client::Actor {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_location( (Actor)arg1, (Location)location) -> None :\n\n    C++ signature :\n        void set_location(carla::client::Actor {lvalue},carla::geom::Location)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_simulate_physics": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_simulate_physics( (Actor)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void set_simulate_physics(carla::client::Actor {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_target_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_target_angular_velocity( (Actor)arg1, (Vector3D)angular_velocity) -> None :\n\n    C++ signature :\n        void set_target_angular_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_target_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_target_velocity( (Actor)arg1, (Vector3D)velocity) -> None :\n\n    C++ signature :\n        void set_target_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_transform( (Actor)arg1, (Transform)transform) -> None :\n\n    C++ signature :\n        void set_transform(carla::client::Actor {lvalue},carla::geom::Transform)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "stop": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "stop( (Sensor)arg1) -> None :\n\n    C++ signature :\n        void stop(carla::client::Sensor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "actor_state": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "attributes": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "bounding_box": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_active": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_alive": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_dormant": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "parent": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "semantic_tags": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "type_id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "Sensor"
            ],
            "source_file": "built-in"
        },
        "CollisionEvent": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "actor": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame_number": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "normal_impulse": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "other_actor": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "timestamp": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "transform": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "SensorData"
            ],
            "source_file": "built-in"
        },
        "Color": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "a": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "b": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "g": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "r": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "ColorConverter": {
            "type": "class",
            "docstring": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "methods": {
                "bit_length": {
                    "type": "method",
                    "signature": "(self, /)",
                    "docstring": "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "conjugate": {
                    "type": "method",
                    "signature": "",
                    "docstring": "Returns self, the complex conjugate of any int.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "from_bytes": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_bytes": {
                    "type": "method",
                    "signature": "(self, /, length, byteorder, *, signed=False)",
                    "docstring": "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {
                "CityScapesPalette": {
                    "type": "ColorConverter",
                    "value": "CityScapesPalette"
                },
                "Depth": {
                    "type": "ColorConverter",
                    "value": "Depth"
                },
                "LogarithmicDepth": {
                    "type": "ColorConverter",
                    "value": "LogarithmicDepth"
                },
                "Raw": {
                    "type": "ColorConverter",
                    "value": "Raw"
                },
                "denominator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'denominator' of 'int' objects>"
                },
                "imag": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'imag' of 'int' objects>"
                },
                "name": {
                    "type": "member_descriptor",
                    "value": "<member 'name' of 'Boost.Python.enum' objects>"
                },
                "names": {
                    "type": "dict",
                    "value": "{'Raw': carla.libcarla.ColorConverter.Raw, 'Depth': carla.libcarla.ColorConverter.Depth, 'LogarithmicDepth': carla.libcarla.ColorConverter.LogarithmicDepth, 'CityScapesPalette': carla.libcarla.ColorConverter.CityScapesPalette}"
                },
                "numerator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'numerator' of 'int' objects>"
                },
                "real": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'real' of 'int' objects>"
                },
                "values": {
                    "type": "dict",
                    "value": "{0: carla.libcarla.ColorConverter.Raw, 1: carla.libcarla.ColorConverter.Depth, 2: carla.libcarla.ColorConverter.LogarithmicDepth, 3: carla.libcarla.ColorConverter.CityScapesPalette}"
                }
            },
            "base_classes": [
                "enum"
            ],
            "source_file": "built-in"
        },
        "DVSEvent": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "pol": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "t": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "x": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "y": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "DVSEventArray": {
            "type": "class",
            "docstring": "",
            "methods": {
                "to_array": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "to_array( (DVSEventArray)arg1) -> list :\n\n    C++ signature :\n        boost::python::list to_array(carla::sensor::data::DVSEventArray)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_array_pol": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "to_array_pol( (DVSEventArray)arg1) -> list :\n\n    C++ signature :\n        boost::python::list to_array_pol(carla::sensor::data::DVSEventArray)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_array_t": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "to_array_t( (DVSEventArray)arg1) -> list :\n\n    C++ signature :\n        boost::python::list to_array_t(carla::sensor::data::DVSEventArray)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_array_x": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "to_array_x( (DVSEventArray)arg1) -> list :\n\n    C++ signature :\n        boost::python::list to_array_x(carla::sensor::data::DVSEventArray)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_array_y": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "to_array_y( (DVSEventArray)arg1) -> list :\n\n    C++ signature :\n        boost::python::list to_array_y(carla::sensor::data::DVSEventArray)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_image": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "to_image( (DVSEventArray)arg1) -> list :\n\n    C++ signature :\n        boost::python::list to_image(carla::sensor::data::DVSEventArray)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "fov": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame_number": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "height": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "raw_data": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "timestamp": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "transform": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "width": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "SensorData"
            ],
            "source_file": "built-in"
        },
        "DebugHelper": {
            "type": "class",
            "docstring": "",
            "methods": {
                "draw_arrow": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "draw_arrow( (DebugHelper)arg1, (Location)begin, (Location)end [, (float)thickness=0.10000000149011612 [, (float)arrow_size=0.10000000149011612 [, (Color)color=<carla.libcarla.Color object at 0x72eff38ca690> [, (float)life_time=-1.0 [, (bool)persistent_lines=True]]]]]) -> None :\n\n    C++ signature :\n        void draw_arrow(carla::client::DebugHelper {lvalue},carla::geom::Location,carla::geom::Location [,float=0.10000000149011612 [,float=0.10000000149011612 [,carla::sensor::data::Color=<carla.libcarla.Color object at 0x72eff38ca690> [,float=-1.0 [,bool=True]]]]])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "draw_box": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "draw_box( (DebugHelper)arg1, (BoundingBox)box, (Rotation)rotation [, (float)thickness=0.10000000149011612 [, (Color)color=<carla.libcarla.Color object at 0x72eff38ca6f0> [, (float)life_time=-1.0 [, (bool)persistent_lines=True]]]]) -> None :\n\n    C++ signature :\n        void draw_box(carla::client::DebugHelper {lvalue},carla::geom::BoundingBox,carla::geom::Rotation [,float=0.10000000149011612 [,carla::sensor::data::Color=<carla.libcarla.Color object at 0x72eff38ca6f0> [,float=-1.0 [,bool=True]]]])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "draw_line": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "draw_line( (DebugHelper)arg1, (Location)begin, (Location)end [, (float)thickness=0.10000000149011612 [, (Color)color=<carla.libcarla.Color object at 0x72eff38ca630> [, (float)life_time=-1.0 [, (bool)persistent_lines=True]]]]) -> None :\n\n    C++ signature :\n        void draw_line(carla::client::DebugHelper {lvalue},carla::geom::Location,carla::geom::Location [,float=0.10000000149011612 [,carla::sensor::data::Color=<carla.libcarla.Color object at 0x72eff38ca630> [,float=-1.0 [,bool=True]]]])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "draw_point": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "draw_point( (DebugHelper)arg1, (Location)location [, (float)size=0.10000000149011612 [, (Color)color=<carla.libcarla.Color object at 0x72eff38ca5d0> [, (float)life_time=-1.0 [, (bool)persistent_lines=True]]]]) -> None :\n\n    C++ signature :\n        void draw_point(carla::client::DebugHelper {lvalue},carla::geom::Location [,float=0.10000000149011612 [,carla::sensor::data::Color=<carla.libcarla.Color object at 0x72eff38ca5d0> [,float=-1.0 [,bool=True]]]])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "draw_string": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "draw_string( (DebugHelper)arg1, (Location)location, (str)text [, (bool)draw_shadow=False [, (Color)color=<carla.libcarla.Color object at 0x72eff38ca750> [, (float)life_time=-1.0 [, (bool)persistent_lines=True]]]]) -> None :\n\n    C++ signature :\n        void draw_string(carla::client::DebugHelper {lvalue},carla::geom::Location,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=False [,carla::sensor::data::Color=<carla.libcarla.Color object at 0x72eff38ca750> [,float=-1.0 [,bool=True]]]])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "EnvironmentObject": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "bounding_box": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "id": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "name": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "transform": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "type": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "FakeImage": {
            "type": "class",
            "docstring": "",
            "methods": {
                "append": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "append( (object)arg1, (object)arg2) -> None :\n\n    C++ signature :\n        void append(std::vector<unsigned char, std::allocator<unsigned char> > {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "extend": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "extend( (object)arg1, (object)arg2) -> None :\n\n    C++ signature :\n        void extend(std::vector<unsigned char, std::allocator<unsigned char> > {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "fov": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "height": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "raw_data": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "width": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "FloatColor": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "a": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "b": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "g": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "r": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "GBufferTextureID": {
            "type": "class",
            "docstring": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "methods": {
                "bit_length": {
                    "type": "method",
                    "signature": "(self, /)",
                    "docstring": "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "conjugate": {
                    "type": "method",
                    "signature": "",
                    "docstring": "Returns self, the complex conjugate of any int.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "from_bytes": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_bytes": {
                    "type": "method",
                    "signature": "(self, /, length, byteorder, *, signed=False)",
                    "docstring": "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {
                "CustomDepth": {
                    "type": "GBufferTextureID",
                    "value": "CustomDepth"
                },
                "CustomStencil": {
                    "type": "GBufferTextureID",
                    "value": "CustomStencil"
                },
                "GBufferA": {
                    "type": "GBufferTextureID",
                    "value": "GBufferA"
                },
                "GBufferB": {
                    "type": "GBufferTextureID",
                    "value": "GBufferB"
                },
                "GBufferC": {
                    "type": "GBufferTextureID",
                    "value": "GBufferC"
                },
                "GBufferD": {
                    "type": "GBufferTextureID",
                    "value": "GBufferD"
                },
                "GBufferE": {
                    "type": "GBufferTextureID",
                    "value": "GBufferE"
                },
                "GBufferF": {
                    "type": "GBufferTextureID",
                    "value": "GBufferF"
                },
                "SSAO": {
                    "type": "GBufferTextureID",
                    "value": "SSAO"
                },
                "SceneColor": {
                    "type": "GBufferTextureID",
                    "value": "SceneColor"
                },
                "SceneDepth": {
                    "type": "GBufferTextureID",
                    "value": "SceneDepth"
                },
                "SceneStencil": {
                    "type": "GBufferTextureID",
                    "value": "SceneStencil"
                },
                "Velocity": {
                    "type": "GBufferTextureID",
                    "value": "Velocity"
                },
                "denominator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'denominator' of 'int' objects>"
                },
                "imag": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'imag' of 'int' objects>"
                },
                "name": {
                    "type": "member_descriptor",
                    "value": "<member 'name' of 'Boost.Python.enum' objects>"
                },
                "names": {
                    "type": "dict",
                    "value": "{'SceneColor': carla.libcarla.GBufferTextureID.SceneColor, 'SceneDepth': carla.libcarla.GBufferTextureID.SceneDepth, 'SceneStencil': carla.libcarla.GBufferTextureID.SceneStencil, 'GBufferA': carla.libcarla.GBufferTextureID.GBufferA, 'GBufferB': carla.libcarla.GBufferTextureID.GBufferB, 'GBufferC': carla.libcarla.GBufferTextureID.GBufferC, 'GBufferD': carla.libcarla.GBufferTextureID.GBufferD, 'GBufferE': carla.libcarla.GBufferTextureID.GBufferE, 'GBufferF': carla.libcarla.GBufferTextureID.GBufferF, 'Velocity': carla.libcarla.GBufferTextureID.Velocity, 'SSAO': carla.libcarla.GBufferTextureID.SSAO, 'CustomDepth': carla.libcarla.GBufferTextureID.CustomDepth, 'CustomStencil': carla.libcarla.GBufferTextureID.CustomStencil}"
                },
                "numerator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'numerator' of 'int' objects>"
                },
                "real": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'real' of 'int' objects>"
                },
                "values": {
                    "type": "dict",
                    "value": "{0: carla.libcarla.GBufferTextureID.SceneColor, 1: carla.libcarla.GBufferTextureID.SceneDepth, 2: carla.libcarla.GBufferTextureID.SceneStencil, 3: carla.libcarla.GBufferTextureID.GBufferA, 4: carla.libcarla.GBufferTextureID.GBufferB, 5: carla.libcarla.GBufferTextureID.GBufferC, 6: carla.libcarla.GBufferTextureID.GBufferD, 7: carla.libcarla.GBufferTextureID.GBufferE, 8: carla.libcarla.GBufferTextureID.GBufferF, 9: carla.libcarla.GBufferTextureID.Velocity, 10: carla.libcarla.GBufferTextureID.SSAO, 11: carla.libcarla.GBufferTextureID.CustomDepth, 12: carla.libcarla.GBufferTextureID.CustomStencil}"
                }
            },
            "base_classes": [
                "enum"
            ],
            "source_file": "built-in"
        },
        "GearPhysicsControl": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "down_ratio": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "ratio": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "up_ratio": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "GeoLocation": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "altitude": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "latitude": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "longitude": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "GnssMeasurement": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "altitude": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame_number": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "latitude": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "longitude": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "timestamp": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "transform": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "SensorData"
            ],
            "source_file": "built-in"
        },
        "IMUMeasurement": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "accelerometer": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "compass": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame_number": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "gyroscope": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "timestamp": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "transform": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "SensorData"
            ],
            "source_file": "built-in"
        },
        "Image": {
            "type": "class",
            "docstring": "",
            "methods": {
                "convert": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "convert( (Image)arg1, (ColorConverter)color_converter) -> None :\n\n    C++ signature :\n        void convert(carla::sensor::data::ImageTmpl<carla::sensor::data::Color> {lvalue},EColorConverter)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "save_to_disk": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "save_to_disk( (Image)arg1, (str)path [, (ColorConverter)color_converter=carla.libcarla.ColorConverter.Raw]) -> str :\n\n    C++ signature :\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > save_to_disk(carla::sensor::data::ImageTmpl<carla::sensor::data::Color> {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,EColorConverter=carla.libcarla.ColorConverter.Raw])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "fov": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame_number": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "height": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "raw_data": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "timestamp": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "transform": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "width": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "SensorData"
            ],
            "source_file": "built-in"
        },
        "Junction": {
            "type": "class",
            "docstring": "",
            "methods": {
                "get_waypoints": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_waypoints( (Junction)arg1, (LaneType)arg2) -> list :\n\n    C++ signature :\n        boost::python::list get_waypoints(carla::client::Junction,carla::road::Lane::LaneType)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "bounding_box": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "LabelledPoint": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "label": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "location": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "Landmark": {
            "type": "class",
            "docstring": "",
            "methods": {
                "get_lane_validities": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_lane_validities( (Landmark)arg1) -> list :\n\n    C++ signature :\n        boost::python::list get_lane_validities(carla::client::Landmark)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "country": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "distance": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "h_offset": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "height": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_dynamic": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "name": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "orientation": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "pitch": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "road_id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "roll": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "s": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "sub_type": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "t": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "text": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "transform": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "type": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "unit": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "value": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "waypoint": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "width": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "z_offset": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "LandmarkOrientation": {
            "type": "class",
            "docstring": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "methods": {
                "bit_length": {
                    "type": "method",
                    "signature": "(self, /)",
                    "docstring": "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "conjugate": {
                    "type": "method",
                    "signature": "",
                    "docstring": "Returns self, the complex conjugate of any int.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "from_bytes": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_bytes": {
                    "type": "method",
                    "signature": "(self, /, length, byteorder, *, signed=False)",
                    "docstring": "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {
                "Both": {
                    "type": "LandmarkOrientation",
                    "value": "Both"
                },
                "Negative": {
                    "type": "LandmarkOrientation",
                    "value": "Negative"
                },
                "Positive": {
                    "type": "LandmarkOrientation",
                    "value": "Positive"
                },
                "denominator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'denominator' of 'int' objects>"
                },
                "imag": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'imag' of 'int' objects>"
                },
                "name": {
                    "type": "member_descriptor",
                    "value": "<member 'name' of 'Boost.Python.enum' objects>"
                },
                "names": {
                    "type": "dict",
                    "value": "{'Positive': carla.libcarla.LandmarkOrientation.Positive, 'Negative': carla.libcarla.LandmarkOrientation.Negative, 'Both': carla.libcarla.LandmarkOrientation.Both}"
                },
                "numerator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'numerator' of 'int' objects>"
                },
                "real": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'real' of 'int' objects>"
                },
                "values": {
                    "type": "dict",
                    "value": "{0: carla.libcarla.LandmarkOrientation.Positive, 1: carla.libcarla.LandmarkOrientation.Negative, 2: carla.libcarla.LandmarkOrientation.Both}"
                }
            },
            "base_classes": [
                "enum"
            ],
            "source_file": "built-in"
        },
        "LandmarkType": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {},
            "attributes": {
                "AbsoluteNoStop": {
                    "type": "str",
                    "value": "283"
                },
                "AccessForbidden": {
                    "type": "str",
                    "value": "250"
                },
                "AccessForbiddenBicycle": {
                    "type": "str",
                    "value": "254"
                },
                "AccessForbiddenHeight": {
                    "type": "str",
                    "value": "265"
                },
                "AccessForbiddenMotorvehicles": {
                    "type": "str",
                    "value": "251"
                },
                "AccessForbiddenTrucks": {
                    "type": "str",
                    "value": "253"
                },
                "AccessForbiddenWeight": {
                    "type": "str",
                    "value": "263"
                },
                "AccessForbiddenWidth": {
                    "type": "str",
                    "value": "264"
                },
                "AccessForbiddenWrongDirection": {
                    "type": "str",
                    "value": "267"
                },
                "CautionBicycle": {
                    "type": "str",
                    "value": "138"
                },
                "CautionPedestrian": {
                    "type": "str",
                    "value": "133"
                },
                "CityBegin": {
                    "type": "str",
                    "value": "310"
                },
                "CityEnd": {
                    "type": "str",
                    "value": "311"
                },
                "Danger": {
                    "type": "str",
                    "value": "101"
                },
                "DeadEnd": {
                    "type": "str",
                    "value": "357"
                },
                "ForbiddenOvertakingMotorvehicles": {
                    "type": "str",
                    "value": "276"
                },
                "ForbiddenOvertakingTrucks": {
                    "type": "str",
                    "value": "277"
                },
                "ForbiddenUTurn": {
                    "type": "str",
                    "value": "272"
                },
                "HasWayNextIntersection": {
                    "type": "str",
                    "value": "301"
                },
                "Highway": {
                    "type": "str",
                    "value": "330"
                },
                "LanesMerging": {
                    "type": "str",
                    "value": "121"
                },
                "LevelCrossing": {
                    "type": "str",
                    "value": "150"
                },
                "MandatoryLeftRightDirection": {
                    "type": "str",
                    "value": "211"
                },
                "MandatoryTurnDirection": {
                    "type": "str",
                    "value": "209"
                },
                "MaximumSpeed": {
                    "type": "str",
                    "value": "274"
                },
                "PassRightLeft": {
                    "type": "str",
                    "value": "222"
                },
                "PriorityWay": {
                    "type": "str",
                    "value": "306"
                },
                "PriorityWayEnd": {
                    "type": "str",
                    "value": "307"
                },
                "RecomendedSpeed": {
                    "type": "str",
                    "value": "380"
                },
                "RecomendedSpeedEnd": {
                    "type": "str",
                    "value": "381"
                },
                "RestrictedStop": {
                    "type": "str",
                    "value": "286"
                },
                "Roundabout": {
                    "type": "str",
                    "value": "215"
                },
                "StopSign": {
                    "type": "str",
                    "value": "206"
                },
                "TwoChoiceTurnDirection": {
                    "type": "str",
                    "value": "214"
                },
                "YieldSign": {
                    "type": "str",
                    "value": "205"
                }
            },
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "LaneChange": {
            "type": "class",
            "docstring": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "methods": {
                "bit_length": {
                    "type": "method",
                    "signature": "(self, /)",
                    "docstring": "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "conjugate": {
                    "type": "method",
                    "signature": "",
                    "docstring": "Returns self, the complex conjugate of any int.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "from_bytes": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_bytes": {
                    "type": "method",
                    "signature": "(self, /, length, byteorder, *, signed=False)",
                    "docstring": "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {
                "Both": {
                    "type": "LaneChange",
                    "value": "Both"
                },
                "Left": {
                    "type": "LaneChange",
                    "value": "Left"
                },
                "NONE": {
                    "type": "LaneChange",
                    "value": "NONE"
                },
                "Right": {
                    "type": "LaneChange",
                    "value": "Right"
                },
                "denominator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'denominator' of 'int' objects>"
                },
                "imag": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'imag' of 'int' objects>"
                },
                "name": {
                    "type": "member_descriptor",
                    "value": "<member 'name' of 'Boost.Python.enum' objects>"
                },
                "names": {
                    "type": "dict",
                    "value": "{'NONE': carla.libcarla.LaneChange.NONE, 'Right': carla.libcarla.LaneChange.Right, 'Left': carla.libcarla.LaneChange.Left, 'Both': carla.libcarla.LaneChange.Both}"
                },
                "numerator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'numerator' of 'int' objects>"
                },
                "real": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'real' of 'int' objects>"
                },
                "values": {
                    "type": "dict",
                    "value": "{0: carla.libcarla.LaneChange.NONE, 1: carla.libcarla.LaneChange.Right, 2: carla.libcarla.LaneChange.Left, 3: carla.libcarla.LaneChange.Both}"
                }
            },
            "base_classes": [
                "enum"
            ],
            "source_file": "built-in"
        },
        "LaneInvasionEvent": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "actor": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "crossed_lane_markings": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame_number": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "timestamp": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "transform": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "SensorData"
            ],
            "source_file": "built-in"
        },
        "LaneInvasionSensor": {
            "type": "class",
            "docstring": "",
            "methods": {
                "add_angular_impulse": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_angular_impulse( (Actor)arg1, (Vector3D)angular_impulse) -> None :\n\n    C++ signature :\n        void add_angular_impulse(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_force": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_force( (Actor)arg1, (Vector3D)force) -> None :\n\n    C++ signature :\n        void add_force(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_impulse": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_impulse( (Actor)arg1, (Vector3D)impulse) -> None :\n\n    C++ signature :\n        void add_impulse(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_torque": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_torque( (Actor)arg1, (Vector3D)torque) -> None :\n\n    C++ signature :\n        void add_torque(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "destroy": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "destroy( (Actor)arg1) -> bool :\n\n    C++ signature :\n        bool destroy(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "disable_constant_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "disable_constant_velocity( (Actor)arg1) -> None :\n\n    C++ signature :\n        void disable_constant_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "enable_constant_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "enable_constant_velocity( (Actor)arg1, (Vector3D)velocity) -> None :\n\n    C++ signature :\n        void enable_constant_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_acceleration": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_acceleration( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_acceleration(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_angular_velocity( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_angular_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_location( (Actor)arg1) -> Location :\n\n    C++ signature :\n        carla::geom::Location get_location(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_transform( (Actor)arg1) -> Transform :\n\n    C++ signature :\n        carla::geom::Transform get_transform(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_velocity( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_world": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_world( (Actor)arg1) -> World :\n\n    C++ signature :\n        carla::client::World get_world(carla::client::Actor)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "is_listening": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "is_listening( (Sensor)arg1) -> bool :\n\n    C++ signature :\n        bool is_listening(carla::client::Sensor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "listen": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "listen( (Sensor)arg1, (object)callback) -> None :\n\n    C++ signature :\n        void listen(carla::client::Sensor {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_enable_gravity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_enable_gravity( (Actor)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void set_enable_gravity(carla::client::Actor {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_location( (Actor)arg1, (Location)location) -> None :\n\n    C++ signature :\n        void set_location(carla::client::Actor {lvalue},carla::geom::Location)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_simulate_physics": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_simulate_physics( (Actor)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void set_simulate_physics(carla::client::Actor {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_target_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_target_angular_velocity( (Actor)arg1, (Vector3D)angular_velocity) -> None :\n\n    C++ signature :\n        void set_target_angular_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_target_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_target_velocity( (Actor)arg1, (Vector3D)velocity) -> None :\n\n    C++ signature :\n        void set_target_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_transform( (Actor)arg1, (Transform)transform) -> None :\n\n    C++ signature :\n        void set_transform(carla::client::Actor {lvalue},carla::geom::Transform)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "stop": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "stop( (Sensor)arg1) -> None :\n\n    C++ signature :\n        void stop(carla::client::Sensor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "actor_state": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "attributes": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "bounding_box": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_active": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_alive": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_dormant": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "parent": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "semantic_tags": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "type_id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "ClientSideSensor"
            ],
            "source_file": "built-in"
        },
        "LaneMarking": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "color": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "lane_change": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "type": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "width": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "LaneMarkingColor": {
            "type": "class",
            "docstring": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "methods": {
                "bit_length": {
                    "type": "method",
                    "signature": "(self, /)",
                    "docstring": "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "conjugate": {
                    "type": "method",
                    "signature": "",
                    "docstring": "Returns self, the complex conjugate of any int.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "from_bytes": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_bytes": {
                    "type": "method",
                    "signature": "(self, /, length, byteorder, *, signed=False)",
                    "docstring": "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {
                "Blue": {
                    "type": "LaneMarkingColor",
                    "value": "Blue"
                },
                "Green": {
                    "type": "LaneMarkingColor",
                    "value": "Green"
                },
                "Other": {
                    "type": "LaneMarkingColor",
                    "value": "Other"
                },
                "Red": {
                    "type": "LaneMarkingColor",
                    "value": "Red"
                },
                "Standard": {
                    "type": "LaneMarkingColor",
                    "value": "Standard"
                },
                "White": {
                    "type": "LaneMarkingColor",
                    "value": "White"
                },
                "Yellow": {
                    "type": "LaneMarkingColor",
                    "value": "Yellow"
                },
                "denominator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'denominator' of 'int' objects>"
                },
                "imag": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'imag' of 'int' objects>"
                },
                "name": {
                    "type": "member_descriptor",
                    "value": "<member 'name' of 'Boost.Python.enum' objects>"
                },
                "names": {
                    "type": "dict",
                    "value": "{'Standard': carla.libcarla.LaneMarkingColor.Standard, 'Blue': carla.libcarla.LaneMarkingColor.Blue, 'Green': carla.libcarla.LaneMarkingColor.Green, 'Red': carla.libcarla.LaneMarkingColor.Red, 'White': carla.libcarla.LaneMarkingColor.White, 'Yellow': carla.libcarla.LaneMarkingColor.Yellow, 'Other': carla.libcarla.LaneMarkingColor.Other}"
                },
                "numerator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'numerator' of 'int' objects>"
                },
                "real": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'real' of 'int' objects>"
                },
                "values": {
                    "type": "dict",
                    "value": "{0: carla.libcarla.LaneMarkingColor.White, 1: carla.libcarla.LaneMarkingColor.Blue, 2: carla.libcarla.LaneMarkingColor.Green, 3: carla.libcarla.LaneMarkingColor.Red, 4: carla.libcarla.LaneMarkingColor.Yellow, 5: carla.libcarla.LaneMarkingColor.Other}"
                }
            },
            "base_classes": [
                "enum"
            ],
            "source_file": "built-in"
        },
        "LaneMarkingType": {
            "type": "class",
            "docstring": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "methods": {
                "bit_length": {
                    "type": "method",
                    "signature": "(self, /)",
                    "docstring": "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "conjugate": {
                    "type": "method",
                    "signature": "",
                    "docstring": "Returns self, the complex conjugate of any int.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "from_bytes": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_bytes": {
                    "type": "method",
                    "signature": "(self, /, length, byteorder, *, signed=False)",
                    "docstring": "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {
                "BottsDots": {
                    "type": "LaneMarkingType",
                    "value": "BottsDots"
                },
                "Broken": {
                    "type": "LaneMarkingType",
                    "value": "Broken"
                },
                "BrokenBroken": {
                    "type": "LaneMarkingType",
                    "value": "BrokenBroken"
                },
                "BrokenSolid": {
                    "type": "LaneMarkingType",
                    "value": "BrokenSolid"
                },
                "Curb": {
                    "type": "LaneMarkingType",
                    "value": "Curb"
                },
                "Grass": {
                    "type": "LaneMarkingType",
                    "value": "Grass"
                },
                "NONE": {
                    "type": "LaneMarkingType",
                    "value": "NONE"
                },
                "Other": {
                    "type": "LaneMarkingType",
                    "value": "Other"
                },
                "Solid": {
                    "type": "LaneMarkingType",
                    "value": "Solid"
                },
                "SolidBroken": {
                    "type": "LaneMarkingType",
                    "value": "SolidBroken"
                },
                "SolidSolid": {
                    "type": "LaneMarkingType",
                    "value": "SolidSolid"
                },
                "denominator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'denominator' of 'int' objects>"
                },
                "imag": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'imag' of 'int' objects>"
                },
                "name": {
                    "type": "member_descriptor",
                    "value": "<member 'name' of 'Boost.Python.enum' objects>"
                },
                "names": {
                    "type": "dict",
                    "value": "{'NONE': carla.libcarla.LaneMarkingType.NONE, 'Other': carla.libcarla.LaneMarkingType.Other, 'Broken': carla.libcarla.LaneMarkingType.Broken, 'Solid': carla.libcarla.LaneMarkingType.Solid, 'SolidSolid': carla.libcarla.LaneMarkingType.SolidSolid, 'SolidBroken': carla.libcarla.LaneMarkingType.SolidBroken, 'BrokenSolid': carla.libcarla.LaneMarkingType.BrokenSolid, 'BrokenBroken': carla.libcarla.LaneMarkingType.BrokenBroken, 'BottsDots': carla.libcarla.LaneMarkingType.BottsDots, 'Grass': carla.libcarla.LaneMarkingType.Grass, 'Curb': carla.libcarla.LaneMarkingType.Curb}"
                },
                "numerator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'numerator' of 'int' objects>"
                },
                "real": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'real' of 'int' objects>"
                },
                "values": {
                    "type": "dict",
                    "value": "{10: carla.libcarla.LaneMarkingType.NONE, 0: carla.libcarla.LaneMarkingType.Other, 1: carla.libcarla.LaneMarkingType.Broken, 2: carla.libcarla.LaneMarkingType.Solid, 3: carla.libcarla.LaneMarkingType.SolidSolid, 4: carla.libcarla.LaneMarkingType.SolidBroken, 5: carla.libcarla.LaneMarkingType.BrokenSolid, 6: carla.libcarla.LaneMarkingType.BrokenBroken, 7: carla.libcarla.LaneMarkingType.BottsDots, 8: carla.libcarla.LaneMarkingType.Grass, 9: carla.libcarla.LaneMarkingType.Curb}"
                }
            },
            "base_classes": [
                "enum"
            ],
            "source_file": "built-in"
        },
        "LaneType": {
            "type": "class",
            "docstring": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "methods": {
                "bit_length": {
                    "type": "method",
                    "signature": "(self, /)",
                    "docstring": "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "conjugate": {
                    "type": "method",
                    "signature": "",
                    "docstring": "Returns self, the complex conjugate of any int.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "from_bytes": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_bytes": {
                    "type": "method",
                    "signature": "(self, /, length, byteorder, *, signed=False)",
                    "docstring": "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {
                "Any": {
                    "type": "LaneType",
                    "value": "Any"
                },
                "Bidirectional": {
                    "type": "LaneType",
                    "value": "Bidirectional"
                },
                "Biking": {
                    "type": "LaneType",
                    "value": "Biking"
                },
                "Border": {
                    "type": "LaneType",
                    "value": "Border"
                },
                "Driving": {
                    "type": "LaneType",
                    "value": "Driving"
                },
                "Entry": {
                    "type": "LaneType",
                    "value": "Entry"
                },
                "Exit": {
                    "type": "LaneType",
                    "value": "Exit"
                },
                "Median": {
                    "type": "LaneType",
                    "value": "Median"
                },
                "NONE": {
                    "type": "LaneType",
                    "value": "NONE"
                },
                "OffRamp": {
                    "type": "LaneType",
                    "value": "OffRamp"
                },
                "OnRamp": {
                    "type": "LaneType",
                    "value": "OnRamp"
                },
                "Parking": {
                    "type": "LaneType",
                    "value": "Parking"
                },
                "Rail": {
                    "type": "LaneType",
                    "value": "Rail"
                },
                "Restricted": {
                    "type": "LaneType",
                    "value": "Restricted"
                },
                "RoadWorks": {
                    "type": "LaneType",
                    "value": "RoadWorks"
                },
                "Shoulder": {
                    "type": "LaneType",
                    "value": "Shoulder"
                },
                "Sidewalk": {
                    "type": "LaneType",
                    "value": "Sidewalk"
                },
                "Special1": {
                    "type": "LaneType",
                    "value": "Special1"
                },
                "Special2": {
                    "type": "LaneType",
                    "value": "Special2"
                },
                "Special3": {
                    "type": "LaneType",
                    "value": "Special3"
                },
                "Stop": {
                    "type": "LaneType",
                    "value": "Stop"
                },
                "Tram": {
                    "type": "LaneType",
                    "value": "Tram"
                },
                "denominator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'denominator' of 'int' objects>"
                },
                "imag": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'imag' of 'int' objects>"
                },
                "name": {
                    "type": "member_descriptor",
                    "value": "<member 'name' of 'Boost.Python.enum' objects>"
                },
                "names": {
                    "type": "dict",
                    "value": "{'NONE': carla.libcarla.LaneType.NONE, 'Driving': carla.libcarla.LaneType.Driving, 'Stop': carla.libcarla.LaneType.Stop, 'Shoulder': carla.libcarla.LaneType.Shoulder, 'Biking': carla.libcarla.LaneType.Biking, 'Sidewalk': carla.libcarla.LaneType.Sidewalk, 'Border': carla.libcarla.LaneType.Border, 'Restricted': carla.libcarla.LaneType.Restricted, 'Parking': carla.libcarla.LaneType.Parking, 'Bidirectional': carla.libcarla.LaneType.Bidirectional, 'Median': carla.libcarla.LaneType.Median, 'Special1': carla.libcarla.LaneType.Special1, 'Special2': carla.libcarla.LaneType.Special2, 'Special3': carla.libcarla.LaneType.Special3, 'RoadWorks': carla.libcarla.LaneType.RoadWorks, 'Tram': carla.libcarla.LaneType.Tram, 'Rail': carla.libcarla.LaneType.Rail, 'Entry': carla.libcarla.LaneType.Entry, 'Exit': carla.libcarla.LaneType.Exit, 'OffRamp': carla.libcarla.LaneType.OffRamp, 'OnRamp': carla.libcarla.LaneType.OnRamp, 'Any': carla.libcarla.LaneType.Any}"
                },
                "numerator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'numerator' of 'int' objects>"
                },
                "real": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'real' of 'int' objects>"
                },
                "values": {
                    "type": "dict",
                    "value": "{1: carla.libcarla.LaneType.NONE, 2: carla.libcarla.LaneType.Driving, 4: carla.libcarla.LaneType.Stop, 8: carla.libcarla.LaneType.Shoulder, 16: carla.libcarla.LaneType.Biking, 32: carla.libcarla.LaneType.Sidewalk, 64: carla.libcarla.LaneType.Border, 128: carla.libcarla.LaneType.Restricted, 256: carla.libcarla.LaneType.Parking, 512: carla.libcarla.LaneType.Bidirectional, 1024: carla.libcarla.LaneType.Median, 2048: carla.libcarla.LaneType.Special1, 4096: carla.libcarla.LaneType.Special2, 8192: carla.libcarla.LaneType.Special3, 16384: carla.libcarla.LaneType.RoadWorks, 32768: carla.libcarla.LaneType.Tram, 65536: carla.libcarla.LaneType.Rail, 131072: carla.libcarla.LaneType.Entry, 262144: carla.libcarla.LaneType.Exit, 524288: carla.libcarla.LaneType.OffRamp, 1048576: carla.libcarla.LaneType.OnRamp, -2: carla.libcarla.LaneType.Any}"
                }
            },
            "base_classes": [
                "enum"
            ],
            "source_file": "built-in"
        },
        "LidarDetection": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "intensity": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "point": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "LidarMeasurement": {
            "type": "class",
            "docstring": "",
            "methods": {
                "get_point_count": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_point_count( (LidarMeasurement)arg1, (int)channel) -> int :\n\n    C++ signature :\n        unsigned int get_point_count(carla::sensor::data::LidarMeasurement {lvalue},unsigned long)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "save_to_disk": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "save_to_disk( (LidarMeasurement)arg1, (str)path) -> str :\n\n    C++ signature :\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > save_to_disk(carla::sensor::data::LidarMeasurement {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "channels": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame_number": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "horizontal_angle": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "raw_data": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "timestamp": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "transform": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "SensorData"
            ],
            "source_file": "built-in"
        },
        "Light": {
            "type": "class",
            "docstring": "",
            "methods": {
                "set_color": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_color( (Light)arg1, (Color)color) -> None :\n\n    C++ signature :\n        void set_color(carla::client::Light {lvalue},carla::sensor::data::Color)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_intensity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_intensity( (Light)arg1, (float)intensity) -> None :\n\n    C++ signature :\n        void set_intensity(carla::client::Light {lvalue},float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_light_group": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_light_group( (Light)arg1, (LightGroup)light_group) -> None :\n\n    C++ signature :\n        void set_light_group(carla::client::Light {lvalue},carla::rpc::LightState::LightGroup)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_light_state": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_light_state( (Light)arg1, (LightState)light_state) -> None :\n\n    C++ signature :\n        void set_light_state(carla::client::Light {lvalue},carla::client::LightState)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "turn_off": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "turn_off( (Light)arg1) -> None :\n\n    C++ signature :\n        void turn_off(carla::client::Light {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "turn_on": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "turn_on( (Light)arg1) -> None :\n\n    C++ signature :\n        void turn_on(carla::client::Light {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "color": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "intensity": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_on": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "light_group": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "light_state": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "location": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "LightGroup": {
            "type": "class",
            "docstring": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "methods": {
                "bit_length": {
                    "type": "method",
                    "signature": "(self, /)",
                    "docstring": "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "conjugate": {
                    "type": "method",
                    "signature": "",
                    "docstring": "Returns self, the complex conjugate of any int.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "from_bytes": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_bytes": {
                    "type": "method",
                    "signature": "(self, /, length, byteorder, *, signed=False)",
                    "docstring": "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {
                "Building": {
                    "type": "LightGroup",
                    "value": "Building"
                },
                "NONE": {
                    "type": "LightGroup",
                    "value": "NONE"
                },
                "Other": {
                    "type": "LightGroup",
                    "value": "Other"
                },
                "Street": {
                    "type": "LightGroup",
                    "value": "Street"
                },
                "Vehicle": {
                    "type": "LightGroup",
                    "value": "Vehicle"
                },
                "denominator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'denominator' of 'int' objects>"
                },
                "imag": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'imag' of 'int' objects>"
                },
                "name": {
                    "type": "member_descriptor",
                    "value": "<member 'name' of 'Boost.Python.enum' objects>"
                },
                "names": {
                    "type": "dict",
                    "value": "{'NONE': carla.libcarla.LightGroup.NONE, 'Vehicle': carla.libcarla.LightGroup.Vehicle, 'Street': carla.libcarla.LightGroup.Street, 'Building': carla.libcarla.LightGroup.Building, 'Other': carla.libcarla.LightGroup.Other}"
                },
                "numerator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'numerator' of 'int' objects>"
                },
                "real": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'real' of 'int' objects>"
                },
                "values": {
                    "type": "dict",
                    "value": "{0: carla.libcarla.LightGroup.NONE, 1: carla.libcarla.LightGroup.Vehicle, 2: carla.libcarla.LightGroup.Street, 3: carla.libcarla.LightGroup.Building, 4: carla.libcarla.LightGroup.Other}"
                }
            },
            "base_classes": [
                "enum"
            ],
            "source_file": "built-in"
        },
        "LightManager": {
            "type": "class",
            "docstring": "",
            "methods": {
                "get_all_lights": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_all_lights( (LightManager)arg1 [, (LightGroup)light_group=carla.libcarla.LightGroup.NONE]) -> list :\n\n    C++ signature :\n        boost::python::list get_all_lights(carla::client::LightManager [,carla::rpc::LightState::LightGroup=carla.libcarla.LightGroup.NONE])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_color": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_color( (LightManager)arg1, (object)lights) -> list :\n\n    C++ signature :\n        boost::python::list get_color(carla::client::LightManager {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_intensity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_intensity( (LightManager)arg1, (object)lights) -> list :\n\n    C++ signature :\n        boost::python::list get_intensity(carla::client::LightManager {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_light_group": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_light_group( (LightManager)arg1, (object)lights) -> list :\n\n    C++ signature :\n        boost::python::list get_light_group(carla::client::LightManager {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_light_state": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_light_state( (LightManager)arg1, (object)lights) -> list :\n\n    C++ signature :\n        boost::python::list get_light_state(carla::client::LightManager {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_turned_off_lights": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_turned_off_lights( (LightManager)arg1 [, (LightGroup)light_group=carla.libcarla.LightGroup.NONE]) -> list :\n\n    C++ signature :\n        boost::python::list get_turned_off_lights(carla::client::LightManager [,carla::rpc::LightState::LightGroup=carla.libcarla.LightGroup.NONE])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_turned_on_lights": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_turned_on_lights( (LightManager)arg1 [, (LightGroup)light_group=carla.libcarla.LightGroup.NONE]) -> list :\n\n    C++ signature :\n        boost::python::list get_turned_on_lights(carla::client::LightManager [,carla::rpc::LightState::LightGroup=carla.libcarla.LightGroup.NONE])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "is_active": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "is_active( (LightManager)arg1, (object)lights) -> list :\n\n    C++ signature :\n        boost::python::list is_active(carla::client::LightManager {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_active": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_active( (LightManager)arg1, (object)lights, (object)active) -> None :\n\n    C++ signature :\n        void set_active(carla::client::LightManager {lvalue},boost::python::api::object,boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_color": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_color( (LightManager)arg1, (object)lights, (Color)color) -> None :\n\n    C++ signature :\n        void set_color(carla::client::LightManager {lvalue},boost::python::api::object,carla::sensor::data::Color)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_colors": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_colors( (LightManager)arg1, (object)lights, (object)colors) -> None :\n\n    C++ signature :\n        void set_colors(carla::client::LightManager {lvalue},boost::python::api::object,boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_day_night_cycle": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_day_night_cycle( (LightManager)arg1, (bool)active) -> None :\n\n    C++ signature :\n        void set_day_night_cycle(carla::client::LightManager {lvalue},bool)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_intensities": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_intensities( (LightManager)arg1, (object)lights, (object)intensities) -> None :\n\n    C++ signature :\n        void set_intensities(carla::client::LightManager {lvalue},boost::python::api::object,boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_intensity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_intensity( (LightManager)arg1, (object)lights, (float)intensity) -> None :\n\n    C++ signature :\n        void set_intensity(carla::client::LightManager {lvalue},boost::python::api::object,float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_light_group": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_light_group( (LightManager)arg1, (object)lights, (LightGroup)light_group) -> None :\n\n    C++ signature :\n        void set_light_group(carla::client::LightManager {lvalue},boost::python::api::object,carla::rpc::LightState::LightGroup)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_light_groups": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_light_groups( (LightManager)arg1, (object)lights, (object)light_groups) -> None :\n\n    C++ signature :\n        void set_light_groups(carla::client::LightManager {lvalue},boost::python::api::object,boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_light_state": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_light_state( (LightManager)arg1, (object)lights, (LightState)light_state) -> None :\n\n    C++ signature :\n        void set_light_state(carla::client::LightManager {lvalue},boost::python::api::object,carla::client::LightState {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_light_states": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_light_states( (LightManager)arg1, (object)lights, (object)light_states) -> None :\n\n    C++ signature :\n        void set_light_states(carla::client::LightManager {lvalue},boost::python::api::object,boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "turn_off": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "turn_off( (LightManager)arg1, (object)lights) -> None :\n\n    C++ signature :\n        void turn_off(carla::client::LightManager {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "turn_on": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "turn_on( (LightManager)arg1, (object)lights) -> None :\n\n    C++ signature :\n        void turn_on(carla::client::LightManager {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "LightState": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "active": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "color": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "group": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "intensity": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "Location": {
            "type": "class",
            "docstring": "",
            "methods": {
                "cross": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "cross( (Vector3D)arg1, (Vector3D)vector) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D cross(carla::geom::Vector3D,carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "distance": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "distance( (Location)arg1, (Location)location) -> float :\n\n    C++ signature :\n        float distance(carla::geom::Location {lvalue},carla::geom::Location)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "distance_2d": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "distance_2d( (Vector3D)arg1, (Vector3D)vector) -> float :\n\n    C++ signature :\n        float distance_2d(carla::geom::Vector3D,carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "distance_squared": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "distance_squared( (Vector3D)arg1, (Vector3D)vector) -> float :\n\n    C++ signature :\n        float distance_squared(carla::geom::Vector3D,carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "distance_squared_2d": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "distance_squared_2d( (Vector3D)arg1, (Vector3D)vector) -> float :\n\n    C++ signature :\n        float distance_squared_2d(carla::geom::Vector3D,carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "dot": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "dot( (Vector3D)arg1, (Vector3D)vector) -> float :\n\n    C++ signature :\n        float dot(carla::geom::Vector3D,carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "dot_2d": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "dot_2d( (Vector3D)arg1, (Vector3D)vector) -> float :\n\n    C++ signature :\n        float dot_2d(carla::geom::Vector3D,carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_vector_angle": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_vector_angle( (Vector3D)arg1, (Vector3D)vector) -> float :\n\n    C++ signature :\n        double get_vector_angle(carla::geom::Vector3D,carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "length": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "length( (Vector3D)arg1) -> float :\n\n    C++ signature :\n        float length(carla::geom::Vector3D {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "make_unit_vector": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "make_unit_vector( (Vector3D)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D make_unit_vector(carla::geom::Vector3D {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "squared_length": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "squared_length( (Vector3D)arg1) -> float :\n\n    C++ signature :\n        float squared_length(carla::geom::Vector3D {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "x": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "y": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "z": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "Vector3D"
            ],
            "source_file": "built-in"
        },
        "Map": {
            "type": "class",
            "docstring": "",
            "methods": {
                "cook_in_memory_map": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "cook_in_memory_map( (Map)arg1 [, (str)path='']) -> None :\n\n    C++ signature :\n        void cook_in_memory_map(carla::client::Map {lvalue} [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=''])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "generate_waypoints": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "generate_waypoints( (Map)arg1, (float)distance) -> list :\n\n    C++ signature :\n        boost::python::list generate_waypoints(carla::client::Map,double)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_all_landmarks": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_all_landmarks( (Map)arg1) -> list :\n\n    C++ signature :\n        boost::python::list get_all_landmarks(carla::client::Map)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_all_landmarks_from_id": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_all_landmarks_from_id( (Map)arg1, (str)opendrive_id) -> list :\n\n    C++ signature :\n        boost::python::list get_all_landmarks_from_id(carla::client::Map,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_all_landmarks_of_type": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_all_landmarks_of_type( (Map)arg1, (str)type) -> list :\n\n    C++ signature :\n        boost::python::list get_all_landmarks_of_type(carla::client::Map,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_crosswalks": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_crosswalks( (Map)arg1) -> list :\n\n    C++ signature :\n        boost::python::list get_crosswalks(carla::client::Map)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_landmark_group": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_landmark_group( (Map)arg1, (Landmark)landmark) -> list :\n\n    C++ signature :\n        boost::python::list get_landmark_group(carla::client::Map,carla::client::Landmark)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_spawn_points": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_spawn_points( (Map)arg1) -> list :\n\n    C++ signature :\n        boost::python::list get_spawn_points(carla::client::Map)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_topology": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_topology( (Map)arg1) -> list :\n\n    C++ signature :\n        boost::python::list get_topology(carla::client::Map)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_waypoint": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_waypoint( (Map)arg1, (Location)location [, (bool)project_to_road=True [, (GBufferTextureID)lane_type=carla.libcarla.LaneType.Driving]]) -> Waypoint :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::Waypoint> get_waypoint(carla::client::Map {lvalue},carla::geom::Location [,bool=True [,int=carla.libcarla.LaneType.Driving]])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_waypoint_xodr": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_waypoint_xodr( (Map)arg1, (int)road_id, (GBufferTextureID)lane_id, (float)s) -> Waypoint :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::Waypoint> get_waypoint_xodr(carla::client::Map {lvalue},unsigned int,int,float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "save_to_disk": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "save_to_disk( (Map)arg1 [, (str)path='']) -> None :\n\n    C++ signature :\n        void save_to_disk(carla::client::Map [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=''])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_opendrive": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "to_opendrive( (Map)arg1) -> str :\n\n    C++ signature :\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > to_opendrive(carla::client::Map)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "transform_to_geolocation": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "transform_to_geolocation( (Map)arg1, (Location)location) -> GeoLocation :\n\n    C++ signature :\n        carla::geom::GeoLocation transform_to_geolocation(carla::client::Map,carla::geom::Location)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "name": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "MapLayer": {
            "type": "class",
            "docstring": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "methods": {
                "bit_length": {
                    "type": "method",
                    "signature": "(self, /)",
                    "docstring": "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "conjugate": {
                    "type": "method",
                    "signature": "",
                    "docstring": "Returns self, the complex conjugate of any int.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "from_bytes": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_bytes": {
                    "type": "method",
                    "signature": "(self, /, length, byteorder, *, signed=False)",
                    "docstring": "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {
                "All": {
                    "type": "MapLayer",
                    "value": "All"
                },
                "Buildings": {
                    "type": "MapLayer",
                    "value": "Buildings"
                },
                "Decals": {
                    "type": "MapLayer",
                    "value": "Decals"
                },
                "Foliage": {
                    "type": "MapLayer",
                    "value": "Foliage"
                },
                "Ground": {
                    "type": "MapLayer",
                    "value": "Ground"
                },
                "NONE": {
                    "type": "MapLayer",
                    "value": "NONE"
                },
                "ParkedVehicles": {
                    "type": "MapLayer",
                    "value": "ParkedVehicles"
                },
                "Particles": {
                    "type": "MapLayer",
                    "value": "Particles"
                },
                "Props": {
                    "type": "MapLayer",
                    "value": "Props"
                },
                "StreetLights": {
                    "type": "MapLayer",
                    "value": "StreetLights"
                },
                "Walls": {
                    "type": "MapLayer",
                    "value": "Walls"
                },
                "denominator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'denominator' of 'int' objects>"
                },
                "imag": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'imag' of 'int' objects>"
                },
                "name": {
                    "type": "member_descriptor",
                    "value": "<member 'name' of 'Boost.Python.enum' objects>"
                },
                "names": {
                    "type": "dict",
                    "value": "{'NONE': carla.libcarla.MapLayer.NONE, 'Buildings': carla.libcarla.MapLayer.Buildings, 'Decals': carla.libcarla.MapLayer.Decals, 'Foliage': carla.libcarla.MapLayer.Foliage, 'Ground': carla.libcarla.MapLayer.Ground, 'ParkedVehicles': carla.libcarla.MapLayer.ParkedVehicles, 'Particles': carla.libcarla.MapLayer.Particles, 'Props': carla.libcarla.MapLayer.Props, 'StreetLights': carla.libcarla.MapLayer.StreetLights, 'Walls': carla.libcarla.MapLayer.Walls, 'All': carla.libcarla.MapLayer.All}"
                },
                "numerator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'numerator' of 'int' objects>"
                },
                "real": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'real' of 'int' objects>"
                },
                "values": {
                    "type": "dict",
                    "value": "{0: carla.libcarla.MapLayer.NONE, 1: carla.libcarla.MapLayer.Buildings, 2: carla.libcarla.MapLayer.Decals, 4: carla.libcarla.MapLayer.Foliage, 8: carla.libcarla.MapLayer.Ground, 16: carla.libcarla.MapLayer.ParkedVehicles, 32: carla.libcarla.MapLayer.Particles, 64: carla.libcarla.MapLayer.Props, 128: carla.libcarla.MapLayer.StreetLights, 256: carla.libcarla.MapLayer.Walls, 65535: carla.libcarla.MapLayer.All}"
                }
            },
            "base_classes": [
                "enum"
            ],
            "source_file": "built-in"
        },
        "MaterialParameter": {
            "type": "class",
            "docstring": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "methods": {
                "bit_length": {
                    "type": "method",
                    "signature": "(self, /)",
                    "docstring": "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "conjugate": {
                    "type": "method",
                    "signature": "",
                    "docstring": "Returns self, the complex conjugate of any int.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "from_bytes": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_bytes": {
                    "type": "method",
                    "signature": "(self, /, length, byteorder, *, signed=False)",
                    "docstring": "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {
                "AO_Roughness_Metallic_Emissive": {
                    "type": "MaterialParameter",
                    "value": "AO_Roughness_Metallic_Emissive"
                },
                "Diffuse": {
                    "type": "MaterialParameter",
                    "value": "Diffuse"
                },
                "Emissive": {
                    "type": "MaterialParameter",
                    "value": "Emissive"
                },
                "Normal": {
                    "type": "MaterialParameter",
                    "value": "Normal"
                },
                "denominator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'denominator' of 'int' objects>"
                },
                "imag": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'imag' of 'int' objects>"
                },
                "name": {
                    "type": "member_descriptor",
                    "value": "<member 'name' of 'Boost.Python.enum' objects>"
                },
                "names": {
                    "type": "dict",
                    "value": "{'Normal': carla.libcarla.MaterialParameter.Normal, 'AO_Roughness_Metallic_Emissive': carla.libcarla.MaterialParameter.AO_Roughness_Metallic_Emissive, 'Diffuse': carla.libcarla.MaterialParameter.Diffuse, 'Emissive': carla.libcarla.MaterialParameter.Emissive}"
                },
                "numerator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'numerator' of 'int' objects>"
                },
                "real": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'real' of 'int' objects>"
                },
                "values": {
                    "type": "dict",
                    "value": "{0: carla.libcarla.MaterialParameter.Normal, 1: carla.libcarla.MaterialParameter.AO_Roughness_Metallic_Emissive, 2: carla.libcarla.MaterialParameter.Diffuse, 3: carla.libcarla.MaterialParameter.Emissive}"
                }
            },
            "base_classes": [
                "enum"
            ],
            "source_file": "built-in"
        },
        "ObstacleDetectionEvent": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "actor": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "distance": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame_number": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "other_actor": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "timestamp": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "transform": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "SensorData"
            ],
            "source_file": "built-in"
        },
        "OpendriveGenerationParameters": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "additional_width": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "enable_mesh_visibility": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "enable_pedestrian_navigation": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "max_road_length": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "smooth_junctions": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "vertex_distance": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "wall_height": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "OpticalFlowImage": {
            "type": "class",
            "docstring": "",
            "methods": {
                "get_color_coded_flow": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_color_coded_flow( (OpticalFlowImage)arg1) -> FakeImage :\n\n    C++ signature :\n        FakeImage get_color_coded_flow(carla::sensor::data::ImageTmpl<carla::sensor::data::OpticalFlowPixel> {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "fov": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame_number": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "height": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "raw_data": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "timestamp": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "transform": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "width": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "SensorData"
            ],
            "source_file": "built-in"
        },
        "OpticalFlowPixel": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "x": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "y": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "Osm2Odr": {
            "type": "class",
            "docstring": "",
            "methods": {
                "convert": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "convert( (str)osm_file [, (Osm2OdrSettings)settings=<carla.libcarla.Osm2OdrSettings object at 0x72eff399c1d0>]) -> str :\n\n    C++ signature :\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > convert(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,osm2odr::OSM2ODRSettings=<carla.libcarla.Osm2OdrSettings object at 0x72eff399c1d0>])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "Osm2OdrSettings": {
            "type": "class",
            "docstring": "",
            "methods": {
                "set_osm_way_types": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_osm_way_types( (Osm2OdrSettings)arg1, (list)way_types) -> None :\n\n    C++ signature :\n        void set_osm_way_types(osm2odr::OSM2ODRSettings {lvalue},boost::python::list)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_traffic_light_excluded_way_types": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_traffic_light_excluded_way_types( (Osm2OdrSettings)arg1, (list)way_types) -> None :\n\n    C++ signature :\n        void set_traffic_light_excluded_way_types(osm2odr::OSM2ODRSettings {lvalue},boost::python::list)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "all_junctions_with_traffic_lights": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "center_map": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "default_lane_width": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "elevation_layer_height": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "generate_traffic_lights": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "offset_x": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "offset_y": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "proj_string": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "use_offsets": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "RadarDetection": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "altitude": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "azimuth": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "depth": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "velocity": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "RadarMeasurement": {
            "type": "class",
            "docstring": "",
            "methods": {
                "get_detection_count": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_detection_count( (RadarMeasurement)arg1) -> int :\n\n    C++ signature :\n        unsigned long get_detection_count(carla::sensor::data::RadarMeasurement {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "frame": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame_number": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "raw_data": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "timestamp": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "transform": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "SensorData"
            ],
            "source_file": "built-in"
        },
        "Rotation": {
            "type": "class",
            "docstring": "",
            "methods": {
                "get_forward_vector": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_forward_vector( (Rotation)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_forward_vector(carla::geom::Rotation {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_right_vector": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_right_vector( (Rotation)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_right_vector(carla::geom::Rotation {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_up_vector": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_up_vector( (Rotation)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_up_vector(carla::geom::Rotation {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "pitch": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "roll": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "yaw": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "SemanticLidarDetection": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "cos_inc_angle": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "object_idx": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "object_tag": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "point": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "SemanticLidarMeasurement": {
            "type": "class",
            "docstring": "",
            "methods": {
                "get_point_count": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_point_count( (SemanticLidarMeasurement)arg1, (int)channel) -> int :\n\n    C++ signature :\n        unsigned int get_point_count(carla::sensor::data::SemanticLidarMeasurement {lvalue},unsigned long)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "save_to_disk": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "save_to_disk( (SemanticLidarMeasurement)arg1, (str)path) -> str :\n\n    C++ signature :\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > save_to_disk(carla::sensor::data::SemanticLidarMeasurement {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "channels": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame_number": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "horizontal_angle": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "raw_data": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "timestamp": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "transform": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "SensorData"
            ],
            "source_file": "built-in"
        },
        "Sensor": {
            "type": "class",
            "docstring": "",
            "methods": {
                "add_angular_impulse": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_angular_impulse( (Actor)arg1, (Vector3D)angular_impulse) -> None :\n\n    C++ signature :\n        void add_angular_impulse(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_force": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_force( (Actor)arg1, (Vector3D)force) -> None :\n\n    C++ signature :\n        void add_force(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_impulse": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_impulse( (Actor)arg1, (Vector3D)impulse) -> None :\n\n    C++ signature :\n        void add_impulse(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_torque": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_torque( (Actor)arg1, (Vector3D)torque) -> None :\n\n    C++ signature :\n        void add_torque(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "destroy": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "destroy( (Actor)arg1) -> bool :\n\n    C++ signature :\n        bool destroy(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "disable_constant_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "disable_constant_velocity( (Actor)arg1) -> None :\n\n    C++ signature :\n        void disable_constant_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "enable_constant_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "enable_constant_velocity( (Actor)arg1, (Vector3D)velocity) -> None :\n\n    C++ signature :\n        void enable_constant_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_acceleration": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_acceleration( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_acceleration(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_angular_velocity( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_angular_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_location( (Actor)arg1) -> Location :\n\n    C++ signature :\n        carla::geom::Location get_location(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_transform( (Actor)arg1) -> Transform :\n\n    C++ signature :\n        carla::geom::Transform get_transform(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_velocity( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_world": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_world( (Actor)arg1) -> World :\n\n    C++ signature :\n        carla::client::World get_world(carla::client::Actor)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "is_listening": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "is_listening( (Sensor)arg1) -> bool :\n\n    C++ signature :\n        bool is_listening(carla::client::Sensor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "listen": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "listen( (Sensor)arg1, (object)callback) -> None :\n\n    C++ signature :\n        void listen(carla::client::Sensor {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_enable_gravity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_enable_gravity( (Actor)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void set_enable_gravity(carla::client::Actor {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_location( (Actor)arg1, (Location)location) -> None :\n\n    C++ signature :\n        void set_location(carla::client::Actor {lvalue},carla::geom::Location)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_simulate_physics": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_simulate_physics( (Actor)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void set_simulate_physics(carla::client::Actor {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_target_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_target_angular_velocity( (Actor)arg1, (Vector3D)angular_velocity) -> None :\n\n    C++ signature :\n        void set_target_angular_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_target_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_target_velocity( (Actor)arg1, (Vector3D)velocity) -> None :\n\n    C++ signature :\n        void set_target_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_transform( (Actor)arg1, (Transform)transform) -> None :\n\n    C++ signature :\n        void set_transform(carla::client::Actor {lvalue},carla::geom::Transform)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "stop": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "stop( (Sensor)arg1) -> None :\n\n    C++ signature :\n        void stop(carla::client::Sensor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "actor_state": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "attributes": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "bounding_box": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_active": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_alive": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_dormant": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "parent": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "semantic_tags": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "type_id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "Actor"
            ],
            "source_file": "built-in"
        },
        "SensorData": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "frame": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame_number": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "timestamp": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "transform": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "ServerSideSensor": {
            "type": "class",
            "docstring": "",
            "methods": {
                "add_angular_impulse": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_angular_impulse( (Actor)arg1, (Vector3D)angular_impulse) -> None :\n\n    C++ signature :\n        void add_angular_impulse(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_force": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_force( (Actor)arg1, (Vector3D)force) -> None :\n\n    C++ signature :\n        void add_force(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_impulse": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_impulse( (Actor)arg1, (Vector3D)impulse) -> None :\n\n    C++ signature :\n        void add_impulse(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_torque": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_torque( (Actor)arg1, (Vector3D)torque) -> None :\n\n    C++ signature :\n        void add_torque(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "destroy": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "destroy( (Actor)arg1) -> bool :\n\n    C++ signature :\n        bool destroy(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "disable_constant_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "disable_constant_velocity( (Actor)arg1) -> None :\n\n    C++ signature :\n        void disable_constant_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "enable_constant_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "enable_constant_velocity( (Actor)arg1, (Vector3D)velocity) -> None :\n\n    C++ signature :\n        void enable_constant_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_acceleration": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_acceleration( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_acceleration(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_angular_velocity( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_angular_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_location( (Actor)arg1) -> Location :\n\n    C++ signature :\n        carla::geom::Location get_location(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_transform( (Actor)arg1) -> Transform :\n\n    C++ signature :\n        carla::geom::Transform get_transform(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_velocity( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_world": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_world( (Actor)arg1) -> World :\n\n    C++ signature :\n        carla::client::World get_world(carla::client::Actor)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "is_listening": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "is_listening( (Sensor)arg1) -> bool :\n\n    C++ signature :\n        bool is_listening(carla::client::Sensor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "is_listening_gbuffer": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "is_listening_gbuffer( (ServerSideSensor)arg1, (int)gbuffer_id) -> bool :\n\n    C++ signature :\n        bool is_listening_gbuffer(carla::client::ServerSideSensor {lvalue},unsigned int)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "listen": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "listen( (Sensor)arg1, (object)callback) -> None :\n\n    C++ signature :\n        void listen(carla::client::Sensor {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "listen_to_gbuffer": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "listen_to_gbuffer( (ServerSideSensor)arg1, (int)gbuffer_id, (object)callback) -> None :\n\n    C++ signature :\n        void listen_to_gbuffer(carla::client::ServerSideSensor {lvalue},unsigned int,boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_enable_gravity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_enable_gravity( (Actor)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void set_enable_gravity(carla::client::Actor {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_location( (Actor)arg1, (Location)location) -> None :\n\n    C++ signature :\n        void set_location(carla::client::Actor {lvalue},carla::geom::Location)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_simulate_physics": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_simulate_physics( (Actor)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void set_simulate_physics(carla::client::Actor {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_target_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_target_angular_velocity( (Actor)arg1, (Vector3D)angular_velocity) -> None :\n\n    C++ signature :\n        void set_target_angular_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_target_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_target_velocity( (Actor)arg1, (Vector3D)velocity) -> None :\n\n    C++ signature :\n        void set_target_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_transform( (Actor)arg1, (Transform)transform) -> None :\n\n    C++ signature :\n        void set_transform(carla::client::Actor {lvalue},carla::geom::Transform)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "stop": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "stop( (Sensor)arg1) -> None :\n\n    C++ signature :\n        void stop(carla::client::Sensor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "stop_gbuffer": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "stop_gbuffer( (ServerSideSensor)arg1, (int)gbuffer_id) -> None :\n\n    C++ signature :\n        void stop_gbuffer(carla::client::ServerSideSensor {lvalue},unsigned int)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "actor_state": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "attributes": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "bounding_box": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_active": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_alive": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_dormant": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "parent": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "semantic_tags": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "type_id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "Sensor"
            ],
            "source_file": "built-in"
        },
        "TextureColor": {
            "type": "class",
            "docstring": "",
            "methods": {
                "get": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get( (TextureColor)arg1, (GBufferTextureID)arg2, (GBufferTextureID)arg3) -> Color :\n\n    C++ signature :\n        carla::sensor::data::Color get(carla::rpc::Texture<carla::sensor::data::Color>,int,int)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set( (TextureColor)arg1, (GBufferTextureID)arg2, (GBufferTextureID)arg3, (Color)arg4) -> None :\n\n    C++ signature :\n        void set(carla::rpc::Texture<carla::sensor::data::Color> {lvalue},int,int,carla::sensor::data::Color {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_dimensions": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_dimensions( (TextureColor)arg1, (int)arg2, (int)arg3) -> None :\n\n    C++ signature :\n        void set_dimensions(carla::rpc::Texture<carla::sensor::data::Color> {lvalue},unsigned int,unsigned int)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "height": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "width": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "TextureFloatColor": {
            "type": "class",
            "docstring": "",
            "methods": {
                "get": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get( (TextureFloatColor)arg1, (GBufferTextureID)arg2, (GBufferTextureID)arg3) -> FloatColor :\n\n    C++ signature :\n        carla::rpc::FloatColor get(carla::rpc::Texture<carla::rpc::FloatColor>,int,int)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set( (TextureFloatColor)arg1, (GBufferTextureID)arg2, (GBufferTextureID)arg3, (FloatColor)arg4) -> None :\n\n    C++ signature :\n        void set(carla::rpc::Texture<carla::rpc::FloatColor> {lvalue},int,int,carla::rpc::FloatColor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_dimensions": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_dimensions( (TextureFloatColor)arg1, (int)arg2, (int)arg3) -> None :\n\n    C++ signature :\n        void set_dimensions(carla::rpc::Texture<carla::rpc::FloatColor> {lvalue},unsigned int,unsigned int)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "height": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "width": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "Timestamp": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "delta_seconds": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "elapsed_seconds": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame_count": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "platform_timestamp": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "TrafficLight": {
            "type": "class",
            "docstring": "",
            "methods": {
                "add_angular_impulse": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_angular_impulse( (Actor)arg1, (Vector3D)angular_impulse) -> None :\n\n    C++ signature :\n        void add_angular_impulse(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_force": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_force( (Actor)arg1, (Vector3D)force) -> None :\n\n    C++ signature :\n        void add_force(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_impulse": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_impulse( (Actor)arg1, (Vector3D)impulse) -> None :\n\n    C++ signature :\n        void add_impulse(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_torque": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_torque( (Actor)arg1, (Vector3D)torque) -> None :\n\n    C++ signature :\n        void add_torque(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "destroy": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "destroy( (Actor)arg1) -> bool :\n\n    C++ signature :\n        bool destroy(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "disable_constant_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "disable_constant_velocity( (Actor)arg1) -> None :\n\n    C++ signature :\n        void disable_constant_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "enable_constant_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "enable_constant_velocity( (Actor)arg1, (Vector3D)velocity) -> None :\n\n    C++ signature :\n        void enable_constant_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "freeze": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "freeze( (TrafficLight)arg1, (bool)freeze) -> None :\n\n    C++ signature :\n        void freeze(carla::client::TrafficLight {lvalue},bool)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_acceleration": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_acceleration( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_acceleration(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_affected_lane_waypoints": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_affected_lane_waypoints( (TrafficLight)arg1) -> list :\n\n    C++ signature :\n        boost::python::list get_affected_lane_waypoints(carla::client::TrafficLight)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_angular_velocity( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_angular_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_elapsed_time": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_elapsed_time( (TrafficLight)arg1) -> float :\n\n    C++ signature :\n        float get_elapsed_time(carla::client::TrafficLight {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_green_time": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_green_time( (TrafficLight)arg1) -> float :\n\n    C++ signature :\n        float get_green_time(carla::client::TrafficLight {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_group_traffic_lights": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_group_traffic_lights( (TrafficLight)arg1) -> list :\n\n    C++ signature :\n        boost::python::list get_group_traffic_lights(carla::client::TrafficLight {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_light_boxes": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_light_boxes( (TrafficLight)arg1) -> list :\n\n    C++ signature :\n        boost::python::list get_light_boxes(carla::client::TrafficLight)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_location( (Actor)arg1) -> Location :\n\n    C++ signature :\n        carla::geom::Location get_location(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_opendrive_id": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_opendrive_id( (TrafficLight)arg1) -> str :\n\n    C++ signature :\n        std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > get_opendrive_id(carla::client::TrafficLight {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_pole_index": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_pole_index( (TrafficLight)arg1) -> int :\n\n    C++ signature :\n        unsigned int get_pole_index(carla::client::TrafficLight {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_red_time": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_red_time( (TrafficLight)arg1) -> float :\n\n    C++ signature :\n        float get_red_time(carla::client::TrafficLight {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_state": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_state( (TrafficLight)arg1) -> TrafficLightState :\n\n    C++ signature :\n        carla::rpc::TrafficLightState get_state(carla::client::TrafficLight {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_stop_waypoints": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_stop_waypoints( (TrafficLight)arg1) -> list :\n\n    C++ signature :\n        boost::python::list get_stop_waypoints(carla::client::TrafficLight)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_transform( (Actor)arg1) -> Transform :\n\n    C++ signature :\n        carla::geom::Transform get_transform(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_velocity( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_world": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_world( (Actor)arg1) -> World :\n\n    C++ signature :\n        carla::client::World get_world(carla::client::Actor)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_yellow_time": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_yellow_time( (TrafficLight)arg1) -> float :\n\n    C++ signature :\n        float get_yellow_time(carla::client::TrafficLight {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "is_frozen": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "is_frozen( (TrafficLight)arg1) -> bool :\n\n    C++ signature :\n        bool is_frozen(carla::client::TrafficLight {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "reset_group": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "reset_group( (TrafficLight)arg1) -> None :\n\n    C++ signature :\n        void reset_group(carla::client::TrafficLight {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_enable_gravity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_enable_gravity( (Actor)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void set_enable_gravity(carla::client::Actor {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_green_time": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_green_time( (TrafficLight)arg1, (float)green_time) -> None :\n\n    C++ signature :\n        void set_green_time(carla::client::TrafficLight {lvalue},float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_location( (Actor)arg1, (Location)location) -> None :\n\n    C++ signature :\n        void set_location(carla::client::Actor {lvalue},carla::geom::Location)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_red_time": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_red_time( (TrafficLight)arg1, (float)red_time) -> None :\n\n    C++ signature :\n        void set_red_time(carla::client::TrafficLight {lvalue},float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_simulate_physics": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_simulate_physics( (Actor)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void set_simulate_physics(carla::client::Actor {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_state": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_state( (TrafficLight)arg1, (TrafficLightState)state) -> None :\n\n    C++ signature :\n        void set_state(carla::client::TrafficLight {lvalue},carla::rpc::TrafficLightState)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_target_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_target_angular_velocity( (Actor)arg1, (Vector3D)angular_velocity) -> None :\n\n    C++ signature :\n        void set_target_angular_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_target_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_target_velocity( (Actor)arg1, (Vector3D)velocity) -> None :\n\n    C++ signature :\n        void set_target_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_transform( (Actor)arg1, (Transform)transform) -> None :\n\n    C++ signature :\n        void set_transform(carla::client::Actor {lvalue},carla::geom::Transform)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_yellow_time": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_yellow_time( (TrafficLight)arg1, (float)yellow_time) -> None :\n\n    C++ signature :\n        void set_yellow_time(carla::client::TrafficLight {lvalue},float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "actor_state": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "attributes": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "bounding_box": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_active": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_alive": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_dormant": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "parent": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "semantic_tags": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "state": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "trigger_volume": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "type_id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "TrafficSign"
            ],
            "source_file": "built-in"
        },
        "TrafficLightState": {
            "type": "class",
            "docstring": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "methods": {
                "bit_length": {
                    "type": "method",
                    "signature": "(self, /)",
                    "docstring": "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "conjugate": {
                    "type": "method",
                    "signature": "",
                    "docstring": "Returns self, the complex conjugate of any int.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "from_bytes": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_bytes": {
                    "type": "method",
                    "signature": "(self, /, length, byteorder, *, signed=False)",
                    "docstring": "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {
                "Green": {
                    "type": "TrafficLightState",
                    "value": "Green"
                },
                "Off": {
                    "type": "TrafficLightState",
                    "value": "Off"
                },
                "Red": {
                    "type": "TrafficLightState",
                    "value": "Red"
                },
                "Unknown": {
                    "type": "TrafficLightState",
                    "value": "Unknown"
                },
                "Yellow": {
                    "type": "TrafficLightState",
                    "value": "Yellow"
                },
                "denominator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'denominator' of 'int' objects>"
                },
                "imag": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'imag' of 'int' objects>"
                },
                "name": {
                    "type": "member_descriptor",
                    "value": "<member 'name' of 'Boost.Python.enum' objects>"
                },
                "names": {
                    "type": "dict",
                    "value": "{'Red': carla.libcarla.TrafficLightState.Red, 'Yellow': carla.libcarla.TrafficLightState.Yellow, 'Green': carla.libcarla.TrafficLightState.Green, 'Off': carla.libcarla.TrafficLightState.Off, 'Unknown': carla.libcarla.TrafficLightState.Unknown}"
                },
                "numerator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'numerator' of 'int' objects>"
                },
                "real": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'real' of 'int' objects>"
                },
                "values": {
                    "type": "dict",
                    "value": "{0: carla.libcarla.TrafficLightState.Red, 1: carla.libcarla.TrafficLightState.Yellow, 2: carla.libcarla.TrafficLightState.Green, 3: carla.libcarla.TrafficLightState.Off, 4: carla.libcarla.TrafficLightState.Unknown}"
                }
            },
            "base_classes": [
                "enum"
            ],
            "source_file": "built-in"
        },
        "TrafficManager": {
            "type": "class",
            "docstring": "",
            "methods": {
                "auto_lane_change": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "auto_lane_change( (TrafficManager)arg1, (Actor)arg2, (bool)arg3) -> None :\n\n    C++ signature :\n        void auto_lane_change(carla::traffic_manager::TrafficManager {lvalue},boost::shared_ptr<carla::client::Actor>,bool)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "collision_detection": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "collision_detection( (TrafficManager)arg1, (Actor)arg2, (Actor)arg3, (bool)arg4) -> None :\n\n    C++ signature :\n        void collision_detection(carla::traffic_manager::TrafficManager {lvalue},boost::shared_ptr<carla::client::Actor>,boost::shared_ptr<carla::client::Actor>,bool)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "distance_to_leading_vehicle": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "distance_to_leading_vehicle( (TrafficManager)arg1, (Actor)arg2, (float)arg3) -> None :\n\n    C++ signature :\n        void distance_to_leading_vehicle(carla::traffic_manager::TrafficManager {lvalue},boost::shared_ptr<carla::client::Actor>,float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "force_lane_change": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "force_lane_change( (TrafficManager)arg1, (Actor)arg2, (bool)arg3) -> None :\n\n    C++ signature :\n        void force_lane_change(carla::traffic_manager::TrafficManager {lvalue},boost::shared_ptr<carla::client::Actor>,bool)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_all_actions": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_all_actions( (TrafficManager)arg1, (Actor)arg2) -> list :\n\n    C++ signature :\n        boost::python::list get_all_actions(carla::traffic_manager::TrafficManager {lvalue},boost::shared_ptr<carla::client::Actor>)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_next_action": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_next_action( (TrafficManager)arg1, (Actor)arg2) -> list :\n\n    C++ signature :\n        boost::python::list get_next_action(carla::traffic_manager::TrafficManager {lvalue},boost::shared_ptr<carla::client::Actor>)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_port": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_port( (TrafficManager)arg1) -> int :\n\n    C++ signature :\n        unsigned short get_port(carla::traffic_manager::TrafficManager {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "global_lane_offset": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "global_lane_offset( (TrafficManager)arg1, (float)arg2) -> None :\n\n    C++ signature :\n        void global_lane_offset(carla::traffic_manager::TrafficManager {lvalue},float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "global_percentage_speed_difference": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "global_percentage_speed_difference( (TrafficManager)arg1, (float)arg2) -> None :\n\n    C++ signature :\n        void global_percentage_speed_difference(carla::traffic_manager::TrafficManager {lvalue},float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "ignore_lights_percentage": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "ignore_lights_percentage( (TrafficManager)arg1, (Actor)arg2, (float)arg3) -> None :\n\n    C++ signature :\n        void ignore_lights_percentage(carla::traffic_manager::TrafficManager {lvalue},boost::shared_ptr<carla::client::Actor>,float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "ignore_signs_percentage": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "ignore_signs_percentage( (TrafficManager)arg1, (Actor)arg2, (float)arg3) -> None :\n\n    C++ signature :\n        void ignore_signs_percentage(carla::traffic_manager::TrafficManager {lvalue},boost::shared_ptr<carla::client::Actor>,float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "ignore_vehicles_percentage": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "ignore_vehicles_percentage( (TrafficManager)arg1, (Actor)arg2, (float)arg3) -> None :\n\n    C++ signature :\n        void ignore_vehicles_percentage(carla::traffic_manager::TrafficManager {lvalue},boost::shared_ptr<carla::client::Actor>,float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "ignore_walkers_percentage": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "ignore_walkers_percentage( (TrafficManager)arg1, (Actor)arg2, (float)arg3) -> None :\n\n    C++ signature :\n        void ignore_walkers_percentage(carla::traffic_manager::TrafficManager {lvalue},boost::shared_ptr<carla::client::Actor>,float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "keep_right_rule_percentage": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "keep_right_rule_percentage( (TrafficManager)arg1, (Actor)arg2, (float)arg3) -> None :\n\n    C++ signature :\n        void keep_right_rule_percentage(carla::traffic_manager::TrafficManager {lvalue},boost::shared_ptr<carla::client::Actor>,float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "random_left_lanechange_percentage": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "random_left_lanechange_percentage( (TrafficManager)arg1, (Actor)arg2, (float)arg3) -> None :\n\n    C++ signature :\n        void random_left_lanechange_percentage(carla::traffic_manager::TrafficManager {lvalue},boost::shared_ptr<carla::client::Actor>,float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "random_right_lanechange_percentage": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "random_right_lanechange_percentage( (TrafficManager)arg1, (Actor)arg2, (float)arg3) -> None :\n\n    C++ signature :\n        void random_right_lanechange_percentage(carla::traffic_manager::TrafficManager {lvalue},boost::shared_ptr<carla::client::Actor>,float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_boundaries_respawn_dormant_vehicles": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_boundaries_respawn_dormant_vehicles( (TrafficManager)arg1, (float)arg2, (float)arg3) -> None :\n\n    C++ signature :\n        void set_boundaries_respawn_dormant_vehicles(carla::traffic_manager::TrafficManager {lvalue},float,float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_desired_speed": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_desired_speed( (TrafficManager)arg1, (Actor)arg2, (float)arg3) -> None :\n\n    C++ signature :\n        void set_desired_speed(carla::traffic_manager::TrafficManager {lvalue},boost::shared_ptr<carla::client::Actor>,float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_global_distance_to_leading_vehicle": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_global_distance_to_leading_vehicle( (TrafficManager)arg1, (float)arg2) -> None :\n\n    C++ signature :\n        void set_global_distance_to_leading_vehicle(carla::traffic_manager::TrafficManager {lvalue},float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_hybrid_physics_mode": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_hybrid_physics_mode( (TrafficManager)arg1, (bool)arg2) -> None :\n\n    C++ signature :\n        void set_hybrid_physics_mode(carla::traffic_manager::TrafficManager {lvalue},bool)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_hybrid_physics_radius": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_hybrid_physics_radius( (TrafficManager)arg1, (float)arg2) -> None :\n\n    C++ signature :\n        void set_hybrid_physics_radius(carla::traffic_manager::TrafficManager {lvalue},float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_osm_mode": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_osm_mode( (TrafficManager)arg1, (bool)arg2) -> None :\n\n    C++ signature :\n        void set_osm_mode(carla::traffic_manager::TrafficManager {lvalue},bool)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_path": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_path( (TrafficManager)arg1, (Actor)arg2, (list)arg3 [, (bool)empty_buffer=True]) -> None :\n\n    C++ signature :\n        void set_path(carla::traffic_manager::TrafficManager {lvalue},boost::shared_ptr<carla::client::Actor>,boost::python::list [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_random_device_seed": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_random_device_seed( (TrafficManager)arg1, (int)arg2) -> None :\n\n    C++ signature :\n        void set_random_device_seed(carla::traffic_manager::TrafficManager {lvalue},unsigned long)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_respawn_dormant_vehicles": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_respawn_dormant_vehicles( (TrafficManager)arg1, (bool)arg2) -> None :\n\n    C++ signature :\n        void set_respawn_dormant_vehicles(carla::traffic_manager::TrafficManager {lvalue},bool)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_route": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_route( (TrafficManager)arg1, (Actor)arg2, (list)arg3 [, (bool)empty_buffer=True]) -> None :\n\n    C++ signature :\n        void set_route(carla::traffic_manager::TrafficManager {lvalue},boost::shared_ptr<carla::client::Actor>,boost::python::list [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_synchronous_mode": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_synchronous_mode( (TrafficManager)arg1, (bool)arg2) -> None :\n\n    C++ signature :\n        void set_synchronous_mode(carla::traffic_manager::TrafficManager {lvalue},bool)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "shut_down": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "shut_down( (TrafficManager)arg1) -> None :\n\n    C++ signature :\n        void shut_down(carla::traffic_manager::TrafficManager {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "update_vehicle_lights": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "update_vehicle_lights( (TrafficManager)arg1, (Actor)arg2, (bool)arg3) -> None :\n\n    C++ signature :\n        void update_vehicle_lights(carla::traffic_manager::TrafficManager {lvalue},boost::shared_ptr<carla::client::Actor>,bool)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "vehicle_lane_offset": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "vehicle_lane_offset( (TrafficManager)arg1, (Actor)arg2, (float)arg3) -> None :\n\n    C++ signature :\n        void vehicle_lane_offset(carla::traffic_manager::TrafficManager {lvalue},boost::shared_ptr<carla::client::Actor>,float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "vehicle_percentage_speed_difference": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "vehicle_percentage_speed_difference( (TrafficManager)arg1, (Actor)arg2, (float)arg3) -> None :\n\n    C++ signature :\n        void vehicle_percentage_speed_difference(carla::traffic_manager::TrafficManager {lvalue},boost::shared_ptr<carla::client::Actor>,float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "TrafficSign": {
            "type": "class",
            "docstring": "",
            "methods": {
                "add_angular_impulse": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_angular_impulse( (Actor)arg1, (Vector3D)angular_impulse) -> None :\n\n    C++ signature :\n        void add_angular_impulse(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_force": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_force( (Actor)arg1, (Vector3D)force) -> None :\n\n    C++ signature :\n        void add_force(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_impulse": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_impulse( (Actor)arg1, (Vector3D)impulse) -> None :\n\n    C++ signature :\n        void add_impulse(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_torque": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_torque( (Actor)arg1, (Vector3D)torque) -> None :\n\n    C++ signature :\n        void add_torque(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "destroy": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "destroy( (Actor)arg1) -> bool :\n\n    C++ signature :\n        bool destroy(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "disable_constant_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "disable_constant_velocity( (Actor)arg1) -> None :\n\n    C++ signature :\n        void disable_constant_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "enable_constant_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "enable_constant_velocity( (Actor)arg1, (Vector3D)velocity) -> None :\n\n    C++ signature :\n        void enable_constant_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_acceleration": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_acceleration( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_acceleration(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_angular_velocity( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_angular_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_location( (Actor)arg1) -> Location :\n\n    C++ signature :\n        carla::geom::Location get_location(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_transform( (Actor)arg1) -> Transform :\n\n    C++ signature :\n        carla::geom::Transform get_transform(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_velocity( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_world": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_world( (Actor)arg1) -> World :\n\n    C++ signature :\n        carla::client::World get_world(carla::client::Actor)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_enable_gravity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_enable_gravity( (Actor)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void set_enable_gravity(carla::client::Actor {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_location( (Actor)arg1, (Location)location) -> None :\n\n    C++ signature :\n        void set_location(carla::client::Actor {lvalue},carla::geom::Location)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_simulate_physics": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_simulate_physics( (Actor)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void set_simulate_physics(carla::client::Actor {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_target_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_target_angular_velocity( (Actor)arg1, (Vector3D)angular_velocity) -> None :\n\n    C++ signature :\n        void set_target_angular_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_target_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_target_velocity( (Actor)arg1, (Vector3D)velocity) -> None :\n\n    C++ signature :\n        void set_target_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_transform( (Actor)arg1, (Transform)transform) -> None :\n\n    C++ signature :\n        void set_transform(carla::client::Actor {lvalue},carla::geom::Transform)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "actor_state": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "attributes": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "bounding_box": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_active": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_alive": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_dormant": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "parent": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "semantic_tags": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "trigger_volume": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "type_id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "Actor"
            ],
            "source_file": "built-in"
        },
        "Transform": {
            "type": "class",
            "docstring": "",
            "methods": {
                "get_forward_vector": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_forward_vector( (Transform)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_forward_vector(carla::geom::Transform {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_inverse_matrix": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_inverse_matrix( (Transform)arg1) -> list :\n\n    C++ signature :\n        boost::python::list get_inverse_matrix(carla::geom::Transform)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_matrix": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_matrix( (Transform)arg1) -> list :\n\n    C++ signature :\n        boost::python::list get_matrix(carla::geom::Transform)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_right_vector": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_right_vector( (Transform)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_right_vector(carla::geom::Transform {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_up_vector": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_up_vector( (Transform)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_up_vector(carla::geom::Transform {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "transform( (Transform)arg1, (list)arg2) -> None :\n\n    C++ signature :\n        void transform(carla::geom::Transform,boost::python::list {lvalue})\n\ntransform( (Transform)arg1, (Vector3D)in_point) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D transform(carla::geom::Transform,carla::geom::Vector3D {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "transform_vector": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "transform_vector( (Transform)arg1, (Vector3D)in_point) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D transform_vector(carla::geom::Transform,carla::geom::Vector3D {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "location": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "rotation": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "Vector2D": {
            "type": "class",
            "docstring": "",
            "methods": {
                "length": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "length( (Vector2D)arg1) -> float :\n\n    C++ signature :\n        float length(carla::geom::Vector2D {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "make_unit_vector": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "make_unit_vector( (Vector2D)arg1) -> Vector2D :\n\n    C++ signature :\n        carla::geom::Vector2D make_unit_vector(carla::geom::Vector2D {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "squared_length": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "squared_length( (Vector2D)arg1) -> float :\n\n    C++ signature :\n        float squared_length(carla::geom::Vector2D {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "x": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "y": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "Vector3D": {
            "type": "class",
            "docstring": "",
            "methods": {
                "cross": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "cross( (Vector3D)arg1, (Vector3D)vector) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D cross(carla::geom::Vector3D,carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "distance": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "distance( (Vector3D)arg1, (Vector3D)vector) -> float :\n\n    C++ signature :\n        float distance(carla::geom::Vector3D,carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "distance_2d": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "distance_2d( (Vector3D)arg1, (Vector3D)vector) -> float :\n\n    C++ signature :\n        float distance_2d(carla::geom::Vector3D,carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "distance_squared": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "distance_squared( (Vector3D)arg1, (Vector3D)vector) -> float :\n\n    C++ signature :\n        float distance_squared(carla::geom::Vector3D,carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "distance_squared_2d": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "distance_squared_2d( (Vector3D)arg1, (Vector3D)vector) -> float :\n\n    C++ signature :\n        float distance_squared_2d(carla::geom::Vector3D,carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "dot": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "dot( (Vector3D)arg1, (Vector3D)vector) -> float :\n\n    C++ signature :\n        float dot(carla::geom::Vector3D,carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "dot_2d": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "dot_2d( (Vector3D)arg1, (Vector3D)vector) -> float :\n\n    C++ signature :\n        float dot_2d(carla::geom::Vector3D,carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_vector_angle": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_vector_angle( (Vector3D)arg1, (Vector3D)vector) -> float :\n\n    C++ signature :\n        double get_vector_angle(carla::geom::Vector3D,carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "length": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "length( (Vector3D)arg1) -> float :\n\n    C++ signature :\n        float length(carla::geom::Vector3D {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "make_unit_vector": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "make_unit_vector( (Vector3D)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D make_unit_vector(carla::geom::Vector3D {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "squared_length": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "squared_length( (Vector3D)arg1) -> float :\n\n    C++ signature :\n        float squared_length(carla::geom::Vector3D {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "x": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "y": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "z": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "Vehicle": {
            "type": "class",
            "docstring": "",
            "methods": {
                "add_angular_impulse": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_angular_impulse( (Actor)arg1, (Vector3D)angular_impulse) -> None :\n\n    C++ signature :\n        void add_angular_impulse(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_force": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_force( (Actor)arg1, (Vector3D)force) -> None :\n\n    C++ signature :\n        void add_force(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_impulse": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_impulse( (Actor)arg1, (Vector3D)impulse) -> None :\n\n    C++ signature :\n        void add_impulse(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_torque": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_torque( (Actor)arg1, (Vector3D)torque) -> None :\n\n    C++ signature :\n        void add_torque(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "apply_ackermann_control": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "apply_ackermann_control( (Vehicle)arg1, (VehicleAckermannControl)control) -> None :\n\n    C++ signature :\n        void apply_ackermann_control(carla::client::Vehicle {lvalue},carla::rpc::VehicleAckermannControl)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "apply_ackermann_controller_settings": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "apply_ackermann_controller_settings( (Vehicle)arg1, (AckermannControllerSettings)settings) -> None :\n\n    C++ signature :\n        void apply_ackermann_controller_settings(carla::client::Vehicle {lvalue},carla::rpc::AckermannControllerSettings)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "apply_control": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "apply_control( (Vehicle)arg1, (VehicleControl)control) -> None :\n\n    C++ signature :\n        void apply_control(carla::client::Vehicle {lvalue},carla::rpc::VehicleControl)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "apply_physics_control": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "apply_physics_control( (Vehicle)arg1, (VehiclePhysicsControl)physics_control) -> None :\n\n    C++ signature :\n        void apply_physics_control(carla::client::Vehicle {lvalue},carla::rpc::VehiclePhysicsControl)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "close_door": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "close_door( (Vehicle)arg1, (VehicleDoor)door_idx) -> None :\n\n    C++ signature :\n        void close_door(carla::client::Vehicle {lvalue},carla::rpc::VehicleDoor)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "destroy": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "destroy( (Actor)arg1) -> bool :\n\n    C++ signature :\n        bool destroy(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "disable_constant_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "disable_constant_velocity( (Actor)arg1) -> None :\n\n    C++ signature :\n        void disable_constant_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "enable_carsim": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "enable_carsim( (Vehicle)arg1 [, (str)simfile_path='']) -> None :\n\n    C++ signature :\n        void enable_carsim(carla::client::Vehicle {lvalue} [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >=''])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "enable_chrono_physics": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "enable_chrono_physics( (Vehicle)arg1 [, (int)max_substeps=30 [, (float)max_substep_delta_time=0.002 [, (str)vehicle_json='' [, (str)powetrain_json='' [, (str)tire_json='' [, (str)base_json_path='']]]]]]) -> None :\n\n    C++ signature :\n        void enable_chrono_physics(carla::client::Vehicle {lvalue} [,unsigned long=30 [,float=0.002 [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >='' [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >='' [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >='' [,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >='']]]]]])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "enable_constant_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "enable_constant_velocity( (Actor)arg1, (Vector3D)velocity) -> None :\n\n    C++ signature :\n        void enable_constant_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_acceleration": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_acceleration( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_acceleration(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_ackermann_controller_settings": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_ackermann_controller_settings( (Vehicle)arg1) -> AckermannControllerSettings :\n\n    C++ signature :\n        carla::rpc::AckermannControllerSettings get_ackermann_controller_settings(carla::client::Vehicle)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_angular_velocity( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_angular_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_control": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_control( (Vehicle)arg1) -> VehicleControl :\n\n    C++ signature :\n        carla::rpc::VehicleControl get_control(carla::client::Vehicle {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_failure_state": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_failure_state( (Vehicle)arg1) -> VehicleFailureState :\n\n    C++ signature :\n        carla::rpc::VehicleFailureState get_failure_state(carla::client::Vehicle {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_light_state": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_light_state( (Vehicle)arg1) -> VehicleLightState :\n\n    C++ signature :\n        carla::rpc::VehicleLightState::LightState get_light_state(carla::client::Vehicle)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_location( (Actor)arg1) -> Location :\n\n    C++ signature :\n        carla::geom::Location get_location(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_physics_control": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_physics_control( (Vehicle)arg1) -> VehiclePhysicsControl :\n\n    C++ signature :\n        carla::rpc::VehiclePhysicsControl get_physics_control(carla::client::Vehicle)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_speed_limit": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_speed_limit( (Vehicle)arg1) -> float :\n\n    C++ signature :\n        float get_speed_limit(carla::client::Vehicle {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_traffic_light": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_traffic_light( (Vehicle)arg1) -> TrafficLight :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::TrafficLight> get_traffic_light(carla::client::Vehicle {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_traffic_light_state": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_traffic_light_state( (Vehicle)arg1) -> TrafficLightState :\n\n    C++ signature :\n        carla::rpc::TrafficLightState get_traffic_light_state(carla::client::Vehicle {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_transform( (Actor)arg1) -> Transform :\n\n    C++ signature :\n        carla::geom::Transform get_transform(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_velocity( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_wheel_steer_angle": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_wheel_steer_angle( (Vehicle)arg1, (VehicleWheelLocation)wheel_location) -> float :\n\n    C++ signature :\n        float get_wheel_steer_angle(carla::client::Vehicle {lvalue},carla::rpc::VehicleWheelLocation)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_world": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_world( (Actor)arg1) -> World :\n\n    C++ signature :\n        carla::client::World get_world(carla::client::Actor)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "is_at_traffic_light": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "is_at_traffic_light( (Vehicle)arg1) -> bool :\n\n    C++ signature :\n        bool is_at_traffic_light(carla::client::Vehicle {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "open_door": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "open_door( (Vehicle)arg1, (VehicleDoor)door_idx) -> None :\n\n    C++ signature :\n        void open_door(carla::client::Vehicle {lvalue},carla::rpc::VehicleDoor)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_autopilot": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_autopilot( (Vehicle)arg1 [, (bool)enabled=True [, (int)tm_port=8000]]) -> None :\n\n    C++ signature :\n        void set_autopilot(carla::client::Vehicle {lvalue} [,bool=True [,unsigned short=8000]])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_enable_gravity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_enable_gravity( (Actor)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void set_enable_gravity(carla::client::Actor {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_light_state": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_light_state( (Vehicle)arg1, (VehicleLightState)light_state) -> None :\n\n    C++ signature :\n        void set_light_state(carla::client::Vehicle {lvalue},carla::rpc::VehicleLightState::LightState)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_location( (Actor)arg1, (Location)location) -> None :\n\n    C++ signature :\n        void set_location(carla::client::Actor {lvalue},carla::geom::Location)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_simulate_physics": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_simulate_physics( (Actor)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void set_simulate_physics(carla::client::Actor {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_target_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_target_angular_velocity( (Actor)arg1, (Vector3D)angular_velocity) -> None :\n\n    C++ signature :\n        void set_target_angular_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_target_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_target_velocity( (Actor)arg1, (Vector3D)velocity) -> None :\n\n    C++ signature :\n        void set_target_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_transform( (Actor)arg1, (Transform)transform) -> None :\n\n    C++ signature :\n        void set_transform(carla::client::Actor {lvalue},carla::geom::Transform)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_wheel_steer_direction": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_wheel_steer_direction( (Vehicle)arg1, (VehicleWheelLocation)arg2, (float)wheel_location) -> None :\n\n    C++ signature :\n        void set_wheel_steer_direction(carla::client::Vehicle {lvalue},carla::rpc::VehicleWheelLocation,float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "show_debug_telemetry": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "show_debug_telemetry( (Vehicle)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void show_debug_telemetry(carla::client::Vehicle {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "use_carsim_road": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "use_carsim_road( (Vehicle)arg1, (bool)enabled) -> None :\n\n    C++ signature :\n        void use_carsim_road(carla::client::Vehicle {lvalue},bool)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "actor_state": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "attributes": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "bounding_box": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_active": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_alive": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_dormant": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "parent": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "semantic_tags": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "type_id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "Actor"
            ],
            "source_file": "built-in"
        },
        "VehicleAckermannControl": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "acceleration": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "jerk": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "speed": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "steer": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "steer_speed": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "VehicleControl": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "brake": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "gear": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "hand_brake": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "manual_gear_shift": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "reverse": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "steer": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "throttle": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "VehicleDoor": {
            "type": "class",
            "docstring": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "methods": {
                "bit_length": {
                    "type": "method",
                    "signature": "(self, /)",
                    "docstring": "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "conjugate": {
                    "type": "method",
                    "signature": "",
                    "docstring": "Returns self, the complex conjugate of any int.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "from_bytes": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_bytes": {
                    "type": "method",
                    "signature": "(self, /, length, byteorder, *, signed=False)",
                    "docstring": "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {
                "All": {
                    "type": "VehicleDoor",
                    "value": "All"
                },
                "FL": {
                    "type": "VehicleDoor",
                    "value": "FL"
                },
                "FR": {
                    "type": "VehicleDoor",
                    "value": "FR"
                },
                "RL": {
                    "type": "VehicleDoor",
                    "value": "RL"
                },
                "RR": {
                    "type": "VehicleDoor",
                    "value": "RR"
                },
                "denominator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'denominator' of 'int' objects>"
                },
                "imag": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'imag' of 'int' objects>"
                },
                "name": {
                    "type": "member_descriptor",
                    "value": "<member 'name' of 'Boost.Python.enum' objects>"
                },
                "names": {
                    "type": "dict",
                    "value": "{'FL': carla.libcarla.VehicleDoor.FL, 'FR': carla.libcarla.VehicleDoor.FR, 'RL': carla.libcarla.VehicleDoor.RL, 'RR': carla.libcarla.VehicleDoor.RR, 'All': carla.libcarla.VehicleDoor.All}"
                },
                "numerator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'numerator' of 'int' objects>"
                },
                "real": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'real' of 'int' objects>"
                },
                "values": {
                    "type": "dict",
                    "value": "{0: carla.libcarla.VehicleDoor.FL, 1: carla.libcarla.VehicleDoor.FR, 2: carla.libcarla.VehicleDoor.RL, 3: carla.libcarla.VehicleDoor.RR, 6: carla.libcarla.VehicleDoor.All}"
                }
            },
            "base_classes": [
                "enum"
            ],
            "source_file": "built-in"
        },
        "VehicleFailureState": {
            "type": "class",
            "docstring": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "methods": {
                "bit_length": {
                    "type": "method",
                    "signature": "(self, /)",
                    "docstring": "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "conjugate": {
                    "type": "method",
                    "signature": "",
                    "docstring": "Returns self, the complex conjugate of any int.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "from_bytes": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_bytes": {
                    "type": "method",
                    "signature": "(self, /, length, byteorder, *, signed=False)",
                    "docstring": "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {
                "Engine": {
                    "type": "VehicleFailureState",
                    "value": "Engine"
                },
                "NONE": {
                    "type": "VehicleFailureState",
                    "value": "NONE"
                },
                "Rollover": {
                    "type": "VehicleFailureState",
                    "value": "Rollover"
                },
                "TirePuncture": {
                    "type": "VehicleFailureState",
                    "value": "TirePuncture"
                },
                "denominator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'denominator' of 'int' objects>"
                },
                "imag": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'imag' of 'int' objects>"
                },
                "name": {
                    "type": "member_descriptor",
                    "value": "<member 'name' of 'Boost.Python.enum' objects>"
                },
                "names": {
                    "type": "dict",
                    "value": "{'NONE': carla.libcarla.VehicleFailureState.NONE, 'Rollover': carla.libcarla.VehicleFailureState.Rollover, 'Engine': carla.libcarla.VehicleFailureState.Engine, 'TirePuncture': carla.libcarla.VehicleFailureState.TirePuncture}"
                },
                "numerator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'numerator' of 'int' objects>"
                },
                "real": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'real' of 'int' objects>"
                },
                "values": {
                    "type": "dict",
                    "value": "{0: carla.libcarla.VehicleFailureState.NONE, 1: carla.libcarla.VehicleFailureState.Rollover, 2: carla.libcarla.VehicleFailureState.Engine, 3: carla.libcarla.VehicleFailureState.TirePuncture}"
                }
            },
            "base_classes": [
                "enum"
            ],
            "source_file": "built-in"
        },
        "VehicleLightState": {
            "type": "class",
            "docstring": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "methods": {
                "bit_length": {
                    "type": "method",
                    "signature": "(self, /)",
                    "docstring": "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "conjugate": {
                    "type": "method",
                    "signature": "",
                    "docstring": "Returns self, the complex conjugate of any int.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "from_bytes": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_bytes": {
                    "type": "method",
                    "signature": "(self, /, length, byteorder, *, signed=False)",
                    "docstring": "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {
                "All": {
                    "type": "VehicleLightState",
                    "value": "All"
                },
                "Brake": {
                    "type": "VehicleLightState",
                    "value": "Brake"
                },
                "Fog": {
                    "type": "VehicleLightState",
                    "value": "Fog"
                },
                "HighBeam": {
                    "type": "VehicleLightState",
                    "value": "HighBeam"
                },
                "Interior": {
                    "type": "VehicleLightState",
                    "value": "Interior"
                },
                "LeftBlinker": {
                    "type": "VehicleLightState",
                    "value": "LeftBlinker"
                },
                "LowBeam": {
                    "type": "VehicleLightState",
                    "value": "LowBeam"
                },
                "NONE": {
                    "type": "VehicleLightState",
                    "value": "NONE"
                },
                "Position": {
                    "type": "VehicleLightState",
                    "value": "Position"
                },
                "Reverse": {
                    "type": "VehicleLightState",
                    "value": "Reverse"
                },
                "RightBlinker": {
                    "type": "VehicleLightState",
                    "value": "RightBlinker"
                },
                "Special1": {
                    "type": "VehicleLightState",
                    "value": "Special1"
                },
                "Special2": {
                    "type": "VehicleLightState",
                    "value": "Special2"
                },
                "denominator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'denominator' of 'int' objects>"
                },
                "imag": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'imag' of 'int' objects>"
                },
                "name": {
                    "type": "member_descriptor",
                    "value": "<member 'name' of 'Boost.Python.enum' objects>"
                },
                "names": {
                    "type": "dict",
                    "value": "{'NONE': carla.libcarla.VehicleLightState.NONE, 'Position': carla.libcarla.VehicleLightState.Position, 'LowBeam': carla.libcarla.VehicleLightState.LowBeam, 'HighBeam': carla.libcarla.VehicleLightState.HighBeam, 'Brake': carla.libcarla.VehicleLightState.Brake, 'RightBlinker': carla.libcarla.VehicleLightState.RightBlinker, 'LeftBlinker': carla.libcarla.VehicleLightState.LeftBlinker, 'Reverse': carla.libcarla.VehicleLightState.Reverse, 'Fog': carla.libcarla.VehicleLightState.Fog, 'Interior': carla.libcarla.VehicleLightState.Interior, 'Special1': carla.libcarla.VehicleLightState.Special1, 'Special2': carla.libcarla.VehicleLightState.Special2, 'All': carla.libcarla.VehicleLightState.All}"
                },
                "numerator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'numerator' of 'int' objects>"
                },
                "real": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'real' of 'int' objects>"
                },
                "values": {
                    "type": "dict",
                    "value": "{0: carla.libcarla.VehicleLightState.NONE, 1: carla.libcarla.VehicleLightState.Position, 2: carla.libcarla.VehicleLightState.LowBeam, 4: carla.libcarla.VehicleLightState.HighBeam, 8: carla.libcarla.VehicleLightState.Brake, 16: carla.libcarla.VehicleLightState.RightBlinker, 32: carla.libcarla.VehicleLightState.LeftBlinker, 64: carla.libcarla.VehicleLightState.Reverse, 128: carla.libcarla.VehicleLightState.Fog, 256: carla.libcarla.VehicleLightState.Interior, 512: carla.libcarla.VehicleLightState.Special1, 1024: carla.libcarla.VehicleLightState.Special2, 4294967295: carla.libcarla.VehicleLightState.All}"
                }
            },
            "base_classes": [
                "enum"
            ],
            "source_file": "built-in"
        },
        "VehiclePhysicsControl": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "center_of_mass": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "clutch_strength": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "damping_rate_full_throttle": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "damping_rate_zero_throttle_clutch_disengaged": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "damping_rate_zero_throttle_clutch_engaged": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "drag_coefficient": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "final_ratio": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "forward_gears": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "gear_switch_time": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "mass": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "max_rpm": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "moi": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "steering_curve": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "torque_curve": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "use_gear_autobox": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "use_sweep_wheel_collision": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "wheels": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "VehicleWheelLocation": {
            "type": "class",
            "docstring": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
            "methods": {
                "bit_length": {
                    "type": "method",
                    "signature": "(self, /)",
                    "docstring": "Number of bits necessary to represent self in binary.\n\n>>> bin(37)\n'0b100101'\n>>> (37).bit_length()\n6",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "conjugate": {
                    "type": "method",
                    "signature": "",
                    "docstring": "Returns self, the complex conjugate of any int.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                },
                "from_bytes": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "Return the integer represented by the given array of bytes.\n\nbytes\n  Holds the array of bytes to convert.  The argument must either\n  support the buffer protocol or be an iterable object producing bytes.\n  Bytes and bytearray are examples of built-in objects that support the\n  buffer protocol.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Indicates whether two's complement is used to represent the integer.",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "to_bytes": {
                    "type": "method",
                    "signature": "(self, /, length, byteorder, *, signed=False)",
                    "docstring": "Return an array of bytes representing an integer.\n\nlength\n  Length of bytes object to use.  An OverflowError is raised if the\n  integer is not representable with the given number of bytes.\nbyteorder\n  The byte order used to represent the integer.  If byteorder is 'big',\n  the most significant byte is at the beginning of the byte array.  If\n  byteorder is 'little', the most significant byte is at the end of the\n  byte array.  To request the native byte order of the host system, use\n  `sys.byteorder' as the byte order value.\nsigned\n  Determines whether two's complement is used to represent the integer.\n  If signed is False and a negative integer is given, an OverflowError\n  is raised.",
                    "is_builtin": false,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {
                "BL_Wheel": {
                    "type": "VehicleWheelLocation",
                    "value": "BL_Wheel"
                },
                "BR_Wheel": {
                    "type": "VehicleWheelLocation",
                    "value": "BR_Wheel"
                },
                "Back_Wheel": {
                    "type": "VehicleWheelLocation",
                    "value": "Back_Wheel"
                },
                "FL_Wheel": {
                    "type": "VehicleWheelLocation",
                    "value": "FL_Wheel"
                },
                "FR_Wheel": {
                    "type": "VehicleWheelLocation",
                    "value": "FR_Wheel"
                },
                "Front_Wheel": {
                    "type": "VehicleWheelLocation",
                    "value": "Front_Wheel"
                },
                "denominator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'denominator' of 'int' objects>"
                },
                "imag": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'imag' of 'int' objects>"
                },
                "name": {
                    "type": "member_descriptor",
                    "value": "<member 'name' of 'Boost.Python.enum' objects>"
                },
                "names": {
                    "type": "dict",
                    "value": "{'FL_Wheel': carla.libcarla.VehicleWheelLocation.FL_Wheel, 'FR_Wheel': carla.libcarla.VehicleWheelLocation.FR_Wheel, 'BL_Wheel': carla.libcarla.VehicleWheelLocation.BL_Wheel, 'BR_Wheel': carla.libcarla.VehicleWheelLocation.BR_Wheel, 'Front_Wheel': carla.libcarla.VehicleWheelLocation.Front_Wheel, 'Back_Wheel': carla.libcarla.VehicleWheelLocation.Back_Wheel}"
                },
                "numerator": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'numerator' of 'int' objects>"
                },
                "real": {
                    "type": "getset_descriptor",
                    "value": "<attribute 'real' of 'int' objects>"
                },
                "values": {
                    "type": "dict",
                    "value": "{0: carla.libcarla.VehicleWheelLocation.Front_Wheel, 1: carla.libcarla.VehicleWheelLocation.Back_Wheel, 2: carla.libcarla.VehicleWheelLocation.BL_Wheel, 3: carla.libcarla.VehicleWheelLocation.BR_Wheel}"
                }
            },
            "base_classes": [
                "enum"
            ],
            "source_file": "built-in"
        },
        "Walker": {
            "type": "class",
            "docstring": "",
            "methods": {
                "add_angular_impulse": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_angular_impulse( (Actor)arg1, (Vector3D)angular_impulse) -> None :\n\n    C++ signature :\n        void add_angular_impulse(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_force": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_force( (Actor)arg1, (Vector3D)force) -> None :\n\n    C++ signature :\n        void add_force(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_impulse": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_impulse( (Actor)arg1, (Vector3D)impulse) -> None :\n\n    C++ signature :\n        void add_impulse(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_torque": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_torque( (Actor)arg1, (Vector3D)torque) -> None :\n\n    C++ signature :\n        void add_torque(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "apply_control": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "apply_control( (Walker)arg1, (WalkerControl)control) -> None :\n\n    C++ signature :\n        void apply_control(carla::client::Walker {lvalue},carla::rpc::WalkerControl)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "blend_pose": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "blend_pose( (Walker)arg1, (float)blend) -> None :\n\n    C++ signature :\n        void blend_pose(carla::client::Walker {lvalue},float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "destroy": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "destroy( (Actor)arg1) -> bool :\n\n    C++ signature :\n        bool destroy(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "disable_constant_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "disable_constant_velocity( (Actor)arg1) -> None :\n\n    C++ signature :\n        void disable_constant_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "enable_constant_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "enable_constant_velocity( (Actor)arg1, (Vector3D)velocity) -> None :\n\n    C++ signature :\n        void enable_constant_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_acceleration": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_acceleration( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_acceleration(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_angular_velocity( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_angular_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_bones": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_bones( (Walker)arg1) -> WalkerBoneControlOut :\n\n    C++ signature :\n        carla::rpc::WalkerBoneControlOut get_bones(carla::client::Walker {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_control": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_control( (Walker)arg1) -> WalkerControl :\n\n    C++ signature :\n        carla::rpc::WalkerControl get_control(carla::client::Walker {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_location( (Actor)arg1) -> Location :\n\n    C++ signature :\n        carla::geom::Location get_location(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_pose_from_animation": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_pose_from_animation( (Walker)arg1) -> None :\n\n    C++ signature :\n        void get_pose_from_animation(carla::client::Walker {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_transform( (Actor)arg1) -> Transform :\n\n    C++ signature :\n        carla::geom::Transform get_transform(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_velocity( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_world": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_world( (Actor)arg1) -> World :\n\n    C++ signature :\n        carla::client::World get_world(carla::client::Actor)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "hide_pose": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "hide_pose( (Walker)arg1) -> None :\n\n    C++ signature :\n        void hide_pose(carla::client::Walker {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_bones": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_bones( (Walker)arg1, (WalkerBoneControlIn)bones) -> None :\n\n    C++ signature :\n        void set_bones(carla::client::Walker {lvalue},carla::rpc::WalkerBoneControlIn)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_enable_gravity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_enable_gravity( (Actor)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void set_enable_gravity(carla::client::Actor {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_location( (Actor)arg1, (Location)location) -> None :\n\n    C++ signature :\n        void set_location(carla::client::Actor {lvalue},carla::geom::Location)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_simulate_physics": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_simulate_physics( (Actor)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void set_simulate_physics(carla::client::Actor {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_target_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_target_angular_velocity( (Actor)arg1, (Vector3D)angular_velocity) -> None :\n\n    C++ signature :\n        void set_target_angular_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_target_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_target_velocity( (Actor)arg1, (Vector3D)velocity) -> None :\n\n    C++ signature :\n        void set_target_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_transform( (Actor)arg1, (Transform)transform) -> None :\n\n    C++ signature :\n        void set_transform(carla::client::Actor {lvalue},carla::geom::Transform)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "show_pose": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "show_pose( (Walker)arg1) -> None :\n\n    C++ signature :\n        void show_pose(carla::client::Walker {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "actor_state": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "attributes": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "bounding_box": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_active": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_alive": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_dormant": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "parent": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "semantic_tags": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "type_id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "Actor"
            ],
            "source_file": "built-in"
        },
        "WalkerAIController": {
            "type": "class",
            "docstring": "",
            "methods": {
                "add_angular_impulse": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_angular_impulse( (Actor)arg1, (Vector3D)angular_impulse) -> None :\n\n    C++ signature :\n        void add_angular_impulse(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_force": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_force( (Actor)arg1, (Vector3D)force) -> None :\n\n    C++ signature :\n        void add_force(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_impulse": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_impulse( (Actor)arg1, (Vector3D)impulse) -> None :\n\n    C++ signature :\n        void add_impulse(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "add_torque": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "add_torque( (Actor)arg1, (Vector3D)torque) -> None :\n\n    C++ signature :\n        void add_torque(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "destroy": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "destroy( (Actor)arg1) -> bool :\n\n    C++ signature :\n        bool destroy(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "disable_constant_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "disable_constant_velocity( (Actor)arg1) -> None :\n\n    C++ signature :\n        void disable_constant_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "enable_constant_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "enable_constant_velocity( (Actor)arg1, (Vector3D)velocity) -> None :\n\n    C++ signature :\n        void enable_constant_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_acceleration": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_acceleration( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_acceleration(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_angular_velocity( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_angular_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_location( (Actor)arg1) -> Location :\n\n    C++ signature :\n        carla::geom::Location get_location(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_transform( (Actor)arg1) -> Transform :\n\n    C++ signature :\n        carla::geom::Transform get_transform(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_velocity( (Actor)arg1) -> Vector3D :\n\n    C++ signature :\n        carla::geom::Vector3D get_velocity(carla::client::Actor {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_world": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_world( (Actor)arg1) -> World :\n\n    C++ signature :\n        carla::client::World get_world(carla::client::Actor)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "go_to_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "go_to_location( (WalkerAIController)arg1, (Location)destination) -> None :\n\n    C++ signature :\n        void go_to_location(carla::client::WalkerAIController {lvalue},carla::geom::Location)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_enable_gravity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_enable_gravity( (Actor)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void set_enable_gravity(carla::client::Actor {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_location": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_location( (Actor)arg1, (Location)location) -> None :\n\n    C++ signature :\n        void set_location(carla::client::Actor {lvalue},carla::geom::Location)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_max_speed": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_max_speed( (WalkerAIController)arg1, (float)speed) -> None :\n\n    C++ signature :\n        void set_max_speed(carla::client::WalkerAIController {lvalue},float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_simulate_physics": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_simulate_physics( (Actor)arg1 [, (bool)enabled=True]) -> None :\n\n    C++ signature :\n        void set_simulate_physics(carla::client::Actor {lvalue} [,bool=True])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_target_angular_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_target_angular_velocity( (Actor)arg1, (Vector3D)angular_velocity) -> None :\n\n    C++ signature :\n        void set_target_angular_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_target_velocity": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_target_velocity( (Actor)arg1, (Vector3D)velocity) -> None :\n\n    C++ signature :\n        void set_target_velocity(carla::client::Actor {lvalue},carla::geom::Vector3D)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_transform": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_transform( (Actor)arg1, (Transform)transform) -> None :\n\n    C++ signature :\n        void set_transform(carla::client::Actor {lvalue},carla::geom::Transform)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "start": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "start( (WalkerAIController)arg1) -> None :\n\n    C++ signature :\n        void start(carla::client::WalkerAIController {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "stop": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "stop( (WalkerAIController)arg1) -> None :\n\n    C++ signature :\n        void stop(carla::client::WalkerAIController {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "actor_state": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "attributes": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "bounding_box": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_active": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_alive": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_dormant": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "parent": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "semantic_tags": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "type_id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "Actor"
            ],
            "source_file": "built-in"
        },
        "WalkerBoneControlIn": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "bone_transforms": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "WalkerBoneControlOut": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "bone_transforms": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "WalkerControl": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "direction": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "jump": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "speed": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "Waypoint": {
            "type": "class",
            "docstring": "",
            "methods": {
                "get_junction": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_junction( (Waypoint)arg1) -> Junction :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::Junction> get_junction(carla::client::Waypoint {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_landmarks": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_landmarks( (Waypoint)arg1, (float)distance [, (bool)stop_at_junction=False]) -> list :\n\n    C++ signature :\n        boost::python::list get_landmarks(carla::client::Waypoint,double [,bool=False])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_landmarks_of_type": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_landmarks_of_type( (Waypoint)arg1, (float)distance, (str)type [, (bool)stop_at_junction=False]) -> list :\n\n    C++ signature :\n        boost::python::list get_landmarks_of_type(carla::client::Waypoint,double,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > [,bool=False])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_left_lane": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_left_lane( (Waypoint)arg1) -> Waypoint :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::Waypoint> get_left_lane(carla::client::Waypoint {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_right_lane": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_right_lane( (Waypoint)arg1) -> Waypoint :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::Waypoint> get_right_lane(carla::client::Waypoint {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "next": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "next( (Waypoint)arg1, (float)distance) -> list :\n\n    C++ signature :\n        boost::python::list next(carla::client::Waypoint,double)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "next_until_lane_end": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "next_until_lane_end( (Waypoint)arg1, (float)distance) -> list :\n\n    C++ signature :\n        boost::python::list next_until_lane_end(carla::client::Waypoint,double)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "previous": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "previous( (Waypoint)arg1, (float)distance) -> list :\n\n    C++ signature :\n        boost::python::list previous(carla::client::Waypoint,double)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "previous_until_lane_start": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "previous_until_lane_start( (Waypoint)arg1, (float)distance) -> list :\n\n    C++ signature :\n        boost::python::list previous_until_lane_start(carla::client::Waypoint,double)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_intersection": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "is_junction": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "junction_id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "lane_change": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "lane_id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "lane_type": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "lane_width": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "left_lane_marking": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "right_lane_marking": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "road_id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "s": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "section_id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "transform": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "WeatherParameters": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "cloudiness": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "dust_storm": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "fog_density": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "fog_distance": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "fog_falloff": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "mie_scattering_scale": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "precipitation": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "precipitation_deposits": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "rayleigh_scattering_scale": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "scattering_intensity": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "sun_altitude_angle": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "sun_azimuth_angle": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "wetness": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "wind_intensity": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {
                "ClearNight": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=5.000000, cloudiness=5.000000, precipitation=0.000000, precipitation_deposits=0.000000, wind_intensity=10.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=-90.000000, fog_density=60.000000, fog_distance=75.000000, fog_falloff=1.000000, wetness=0.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "ClearNoon": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=5.000000, cloudiness=5.000000, precipitation=0.000000, precipitation_deposits=0.000000, wind_intensity=10.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=45.000000, fog_density=2.000000, fog_distance=0.750000, fog_falloff=0.100000, wetness=0.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "ClearSunset": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=5.000000, cloudiness=5.000000, precipitation=0.000000, precipitation_deposits=0.000000, wind_intensity=10.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=15.000000, fog_density=2.000000, fog_distance=0.750000, fog_falloff=0.100000, wetness=0.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "CloudyNight": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=60.000000, cloudiness=60.000000, precipitation=0.000000, precipitation_deposits=0.000000, wind_intensity=10.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=-90.000000, fog_density=60.000000, fog_distance=0.750000, fog_falloff=0.100000, wetness=0.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "CloudyNoon": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=60.000000, cloudiness=60.000000, precipitation=0.000000, precipitation_deposits=0.000000, wind_intensity=10.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=45.000000, fog_density=3.000000, fog_distance=0.750000, fog_falloff=0.100000, wetness=0.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "CloudySunset": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=60.000000, cloudiness=60.000000, precipitation=0.000000, precipitation_deposits=0.000000, wind_intensity=10.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=15.000000, fog_density=3.000000, fog_distance=0.750000, fog_falloff=0.100000, wetness=0.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "Default": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=-1.000000, cloudiness=-1.000000, precipitation=-1.000000, precipitation_deposits=-1.000000, wind_intensity=-1.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=-1.000000, fog_density=-1.000000, fog_distance=-1.000000, fog_falloff=-1.000000, wetness=-1.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "DustStorm": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=100.000000, cloudiness=100.000000, precipitation=0.000000, precipitation_deposits=0.000000, wind_intensity=100.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=45.000000, fog_density=2.000000, fog_distance=0.750000, fog_falloff=0.100000, wetness=0.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=100.000000)"
                },
                "HardRainNight": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=100.000000, cloudiness=100.000000, precipitation=100.000000, precipitation_deposits=90.000000, wind_intensity=100.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=-90.000000, fog_density=100.000000, fog_distance=0.750000, fog_falloff=0.100000, wetness=100.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "HardRainNoon": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=100.000000, cloudiness=100.000000, precipitation=100.000000, precipitation_deposits=90.000000, wind_intensity=100.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=45.000000, fog_density=7.000000, fog_distance=0.750000, fog_falloff=0.100000, wetness=0.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "HardRainSunset": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=100.000000, cloudiness=100.000000, precipitation=100.000000, precipitation_deposits=90.000000, wind_intensity=100.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=15.000000, fog_density=7.000000, fog_distance=0.750000, fog_falloff=0.100000, wetness=0.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "MidRainSunset": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=60.000000, cloudiness=60.000000, precipitation=60.000000, precipitation_deposits=60.000000, wind_intensity=60.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=15.000000, fog_density=3.000000, fog_distance=0.750000, fog_falloff=0.100000, wetness=0.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "MidRainyNight": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=80.000000, cloudiness=80.000000, precipitation=60.000000, precipitation_deposits=60.000000, wind_intensity=60.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=-90.000000, fog_density=60.000000, fog_distance=0.750000, fog_falloff=0.100000, wetness=80.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "MidRainyNoon": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=60.000000, cloudiness=60.000000, precipitation=60.000000, precipitation_deposits=60.000000, wind_intensity=60.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=45.000000, fog_density=3.000000, fog_distance=0.750000, fog_falloff=0.100000, wetness=0.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "SoftRainNight": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=60.000000, cloudiness=60.000000, precipitation=30.000000, precipitation_deposits=50.000000, wind_intensity=30.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=-90.000000, fog_density=60.000000, fog_distance=0.750000, fog_falloff=0.100000, wetness=60.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "SoftRainNoon": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=20.000000, cloudiness=20.000000, precipitation=30.000000, precipitation_deposits=50.000000, wind_intensity=30.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=45.000000, fog_density=3.000000, fog_distance=0.750000, fog_falloff=0.100000, wetness=0.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "SoftRainSunset": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=20.000000, cloudiness=20.000000, precipitation=30.000000, precipitation_deposits=50.000000, wind_intensity=30.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=15.000000, fog_density=2.000000, fog_distance=0.750000, fog_falloff=0.100000, wetness=0.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "WetCloudyNight": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=60.000000, cloudiness=60.000000, precipitation=0.000000, precipitation_deposits=50.000000, wind_intensity=10.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=-90.000000, fog_density=60.000000, fog_distance=0.750000, fog_falloff=0.100000, wetness=60.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "WetCloudyNoon": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=60.000000, cloudiness=60.000000, precipitation=0.000000, precipitation_deposits=50.000000, wind_intensity=10.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=45.000000, fog_density=3.000000, fog_distance=0.750000, fog_falloff=0.100000, wetness=0.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "WetCloudySunset": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=60.000000, cloudiness=60.000000, precipitation=0.000000, precipitation_deposits=50.000000, wind_intensity=10.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=15.000000, fog_density=2.000000, fog_distance=0.750000, fog_falloff=0.100000, wetness=0.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "WetNight": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=5.000000, cloudiness=5.000000, precipitation=0.000000, precipitation_deposits=50.000000, wind_intensity=10.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=-90.000000, fog_density=60.000000, fog_distance=75.000000, fog_falloff=1.000000, wetness=60.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "WetNoon": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=5.000000, cloudiness=5.000000, precipitation=0.000000, precipitation_deposits=50.000000, wind_intensity=10.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=45.000000, fog_density=3.000000, fog_distance=0.750000, fog_falloff=0.100000, wetness=0.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                },
                "WetSunset": {
                    "type": "WeatherParameters",
                    "value": "WeatherParameters(cloudiness=5.000000, cloudiness=5.000000, precipitation=0.000000, precipitation_deposits=50.000000, wind_intensity=10.000000, sun_azimuth_angle=-1.000000, sun_altitude_angle=15.000000, fog_density=2.000000, fog_distance=0.750000, fog_falloff=0.100000, wetness=0.000000, scattering_intensity=1.000000, mie_scattering_scale=0.030000, rayleigh_scattering_scale=0.033100, dust_storm=0.000000)"
                }
            },
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "WheelPhysicsControl": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "damping_rate": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "lat_stiff_max_load": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "lat_stiff_value": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "long_stiff_value": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "max_brake_torque": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "max_handbrake_torque": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "max_steer_angle": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "position": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "radius": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "tire_friction": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "World": {
            "type": "class",
            "docstring": "",
            "methods": {
                "apply_color_texture_to_object": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "apply_color_texture_to_object( (World)arg1, (str)object_name, (MaterialParameter)material_parameter, (TextureColor)texture) -> None :\n\n    C++ signature :\n        void apply_color_texture_to_object(carla::client::World {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,carla::rpc::MaterialParameter,carla::rpc::Texture<carla::sensor::data::Color>)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "apply_color_texture_to_objects": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "apply_color_texture_to_objects( (World)arg1, (list)objects_name_list, (MaterialParameter)material_parameter, (TextureColor)texture) -> None :\n\n    C++ signature :\n        void apply_color_texture_to_objects(carla::client::World {lvalue},boost::python::list {lvalue},carla::rpc::MaterialParameter,carla::rpc::Texture<carla::sensor::data::Color>)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "apply_float_color_texture_to_object": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "apply_float_color_texture_to_object( (World)arg1, (str)object_name, (MaterialParameter)material_parameter, (TextureFloatColor)texture) -> None :\n\n    C++ signature :\n        void apply_float_color_texture_to_object(carla::client::World {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,carla::rpc::MaterialParameter,carla::rpc::Texture<carla::rpc::FloatColor>)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "apply_float_color_texture_to_objects": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "apply_float_color_texture_to_objects( (World)arg1, (list)objects_name_list, (MaterialParameter)material_parameter, (TextureFloatColor)texture) -> None :\n\n    C++ signature :\n        void apply_float_color_texture_to_objects(carla::client::World {lvalue},boost::python::list {lvalue},carla::rpc::MaterialParameter,carla::rpc::Texture<carla::rpc::FloatColor>)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "apply_settings": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "apply_settings( (World)arg1, (WorldSettings)settings [, (float)seconds=0.0]) -> int :\n\n    C++ signature :\n        unsigned long apply_settings(carla::client::World {lvalue},carla::rpc::EpisodeSettings [,double=0.0])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "apply_textures_to_object": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "apply_textures_to_object( (World)arg1, (str)object_name, (TextureColor)diffuse_texture, (TextureFloatColor)emissive_texture, (TextureFloatColor)normal_texture, (TextureFloatColor)ao_roughness_metallic_emissive_texture) -> None :\n\n    C++ signature :\n        void apply_textures_to_object(carla::client::World {lvalue},std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >,carla::rpc::Texture<carla::sensor::data::Color>,carla::rpc::Texture<carla::rpc::FloatColor>,carla::rpc::Texture<carla::rpc::FloatColor>,carla::rpc::Texture<carla::rpc::FloatColor>)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "apply_textures_to_objects": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "apply_textures_to_objects( (World)arg1, (list)objects_name_list, (TextureColor)diffuse_texture, (TextureFloatColor)emissive_texture, (TextureFloatColor)normal_texture, (TextureFloatColor)ao_roughness_metallic_emissive_texture) -> None :\n\n    C++ signature :\n        void apply_textures_to_objects(carla::client::World {lvalue},boost::python::list {lvalue},carla::rpc::Texture<carla::sensor::data::Color>,carla::rpc::Texture<carla::rpc::FloatColor>,carla::rpc::Texture<carla::rpc::FloatColor>,carla::rpc::Texture<carla::rpc::FloatColor>)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "cast_ray": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "cast_ray( (World)arg1, (Location)initial_location, (Location)final_location) -> list :\n\n    C++ signature :\n        boost::python::list cast_ray(carla::client::World,carla::geom::Location,carla::geom::Location)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "enable_environment_objects": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "enable_environment_objects( (World)arg1, (object)env_objects_ids, (bool)enable) -> None :\n\n    C++ signature :\n        void enable_environment_objects(carla::client::World {lvalue},boost::python::api::object,bool)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "freeze_all_traffic_lights": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "freeze_all_traffic_lights( (World)arg1, (bool)frozen) -> None :\n\n    C++ signature :\n        void freeze_all_traffic_lights(carla::client::World {lvalue},bool)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_actor": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_actor( (World)arg1, (int)actor_id) -> Actor :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::Actor> get_actor(carla::client::World,unsigned int)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_actors": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_actors( (World)arg1) -> ActorList :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::ActorList> get_actors(carla::client::World)\n\nget_actors( (World)arg1, (list)actor_ids) -> ActorList :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::ActorList> get_actors(carla::client::World {lvalue},boost::python::list)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_blueprint_library": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_blueprint_library( (World)arg1) -> BlueprintLibrary :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::BlueprintLibrary> get_blueprint_library(carla::client::World)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_environment_objects": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_environment_objects( (World)arg1 [, (int)object_type=carla.libcarla.CityObjectLabel.Any]) -> list :\n\n    C++ signature :\n        boost::python::list get_environment_objects(carla::client::World [,unsigned char=carla.libcarla.CityObjectLabel.Any])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_level_bbs": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_level_bbs( (World)arg1 [, (int)bb_type=carla.libcarla.CityObjectLabel.Any]) -> list :\n\n    C++ signature :\n        boost::python::list get_level_bbs(carla::client::World [,unsigned char=carla.libcarla.CityObjectLabel.Any])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_lightmanager": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_lightmanager( (World)arg1) -> LightManager :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::LightManager> get_lightmanager(carla::client::World)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_map": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_map( (World)arg1) -> Map :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::Map> get_map(carla::client::World)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_names_of_all_objects": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_names_of_all_objects( (World)arg1) -> list :\n\n    C++ signature :\n        boost::python::list get_names_of_all_objects(carla::client::World)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_random_location_from_navigation": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_random_location_from_navigation( (World)arg1) -> object :\n\n    C++ signature :\n        boost::python::api::object get_random_location_from_navigation(carla::client::World)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_settings": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_settings( (World)arg1) -> WorldSettings :\n\n    C++ signature :\n        carla::rpc::EpisodeSettings get_settings(carla::client::World)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_snapshot": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_snapshot( (World)arg1) -> WorldSnapshot :\n\n    C++ signature :\n        carla::client::WorldSnapshot get_snapshot(carla::client::World {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_spectator": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_spectator( (World)arg1) -> Actor :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::Actor> get_spectator(carla::client::World)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_traffic_light": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_traffic_light( (World)arg1, (Landmark)landmark) -> Actor :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::Actor> get_traffic_light(carla::client::World,carla::client::Landmark)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_traffic_light_from_opendrive_id": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_traffic_light_from_opendrive_id( (World)arg1, (str)traffic_light_id) -> Actor :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::Actor> get_traffic_light_from_opendrive_id(carla::client::World,std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_traffic_lights_from_waypoint": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_traffic_lights_from_waypoint( (World)arg1, (Waypoint)waypoint, (float)distance) -> list :\n\n    C++ signature :\n        boost::python::list get_traffic_lights_from_waypoint(carla::client::World,carla::client::Waypoint,double)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_traffic_lights_in_junction": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_traffic_lights_in_junction( (World)arg1, (GBufferTextureID)junction_id) -> list :\n\n    C++ signature :\n        boost::python::list get_traffic_lights_in_junction(carla::client::World,int)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_traffic_sign": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_traffic_sign( (World)arg1, (Landmark)landmark) -> Actor :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::Actor> get_traffic_sign(carla::client::World,carla::client::Landmark)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_vehicles_light_states": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_vehicles_light_states( (World)arg1) -> dict :\n\n    C++ signature :\n        boost::python::dict get_vehicles_light_states(carla::client::World {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "get_weather": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "get_weather( (World)arg1) -> WeatherParameters :\n\n    C++ signature :\n        carla::rpc::WeatherParameters get_weather(carla::client::World)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "ground_projection": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "ground_projection( (World)arg1, (Location)location [, (float)search_distance=10000.0]) -> object :\n\n    C++ signature :\n        boost::python::api::object ground_projection(carla::client::World,carla::geom::Location [,float=10000.0])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "load_map_layer": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "load_map_layer( (World)arg1, (MapLayer)map_layers) -> None :\n\n    C++ signature :\n        void load_map_layer(carla::client::World,carla::rpc::MapLayer)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "on_tick": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "on_tick( (World)arg1, (object)callback) -> int :\n\n    C++ signature :\n        unsigned long on_tick(carla::client::World {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "project_point": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "project_point( (World)arg1, (Location)location, (Vector3D)direction [, (float)search_distance=10000.0]) -> object :\n\n    C++ signature :\n        boost::python::api::object project_point(carla::client::World,carla::geom::Location,carla::geom::Vector3D [,float=10000.0])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "remove_on_tick": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "remove_on_tick( (World)arg1, (int)callback_id) -> None :\n\n    C++ signature :\n        void remove_on_tick(carla::client::World {lvalue},unsigned long)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "reset_all_traffic_lights": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "reset_all_traffic_lights( (World)arg1) -> None :\n\n    C++ signature :\n        void reset_all_traffic_lights(carla::client::World {lvalue})",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_pedestrians_cross_factor": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_pedestrians_cross_factor( (World)arg1, (float)percentage) -> None :\n\n    C++ signature :\n        void set_pedestrians_cross_factor(carla::client::World {lvalue},float)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_pedestrians_seed": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_pedestrians_seed( (World)arg1, (int)seed) -> None :\n\n    C++ signature :\n        void set_pedestrians_seed(carla::client::World {lvalue},unsigned int)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "set_weather": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "set_weather( (World)arg1, (WeatherParameters)arg2) -> None :\n\n    C++ signature :\n        void set_weather(carla::client::World {lvalue},carla::rpc::WeatherParameters)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "spawn_actor": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "spawn_actor( (World)arg1, (ActorBlueprint)blueprint, (Transform)transform [, (Actor)attach_to=None [, (AttachmentType)attachment_type=carla.libcarla.AttachmentType.Rigid]]) -> Actor :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::Actor> spawn_actor(carla::client::World {lvalue},carla::client::ActorBlueprint,carla::geom::Transform [,carla::client::Actor*=None [,carla::rpc::AttachmentType=carla.libcarla.AttachmentType.Rigid]])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "tick": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "tick( (World)arg1 [, (float)seconds=0.0]) -> int :\n\n    C++ signature :\n        unsigned long tick(carla::client::World {lvalue} [,double=0.0])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "try_spawn_actor": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "try_spawn_actor( (World)arg1, (ActorBlueprint)blueprint, (Transform)transform [, (Actor)attach_to=None [, (AttachmentType)attachment_type=carla.libcarla.AttachmentType.Rigid]]) -> Actor :\n\n    C++ signature :\n        boost::shared_ptr<carla::client::Actor> try_spawn_actor(carla::client::World {lvalue},carla::client::ActorBlueprint,carla::geom::Transform [,carla::client::Actor*=None [,carla::rpc::AttachmentType=carla.libcarla.AttachmentType.Rigid]])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "unload_map_layer": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "unload_map_layer( (World)arg1, (MapLayer)map_layers) -> None :\n\n    C++ signature :\n        void unload_map_layer(carla::client::World,carla::rpc::MapLayer)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "wait_for_tick": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "wait_for_tick( (World)arg1 [, (float)seconds=0.0]) -> WorldSnapshot :\n\n    C++ signature :\n        carla::client::WorldSnapshot wait_for_tick(carla::client::World [,double=0.0])",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "debug": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "WorldSettings": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "actor_active_distance": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "deterministic_ragdolls": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "fixed_delta_seconds": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "max_culling_distance": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "max_substep_delta_time": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "max_substeps": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "no_rendering_mode": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "substepping": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "synchronous_mode": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "tile_stream_distance": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "WorldSnapshot": {
            "type": "class",
            "docstring": "",
            "methods": {
                "find": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "find( (WorldSnapshot)arg1, (int)actor_id) -> object :\n\n    C++ signature :\n        boost::python::api::object find(carla::client::WorldSnapshot,unsigned int)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "has_actor": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "has_actor( (WorldSnapshot)arg1, (int)actor_id) -> bool :\n\n    C++ signature :\n        bool has_actor(carla::client::WorldSnapshot {lvalue},unsigned int)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {
                "delta_seconds": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "elapsed_seconds": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "frame_count": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "id": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "platform_timestamp": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "timestamp": {
                    "type": "property",
                    "readable": true,
                    "writable": false,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "bone_transform": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "name": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "transform": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "bone_transform_out": {
            "type": "class",
            "docstring": "",
            "methods": {},
            "properties": {
                "component": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "name": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "relative": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                },
                "world": {
                    "type": "property",
                    "readable": true,
                    "writable": true,
                    "docstring": "",
                    "getter_signature": "built-in function"
                }
            },
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "vector_of_bones": {
            "type": "class",
            "docstring": "",
            "methods": {
                "append": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "append( (vector_of_bones)arg1, (object)arg2) -> None :\n\n    C++ signature :\n        void append(std::vector<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, carla::geom::Transform>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, carla::geom::Transform> > > {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "extend": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "extend( (vector_of_bones)arg1, (object)arg2) -> None :\n\n    C++ signature :\n        void extend(std::vector<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, carla::geom::Transform>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, carla::geom::Transform> > > {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "vector_of_bones_out": {
            "type": "class",
            "docstring": "",
            "methods": {
                "append": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "append( (vector_of_bones_out)arg1, (object)arg2) -> None :\n\n    C++ signature :\n        void append(std::vector<carla::rpc::BoneTransformDataOut, std::allocator<carla::rpc::BoneTransformDataOut> > {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "extend": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "extend( (vector_of_bones_out)arg1, (object)arg2) -> None :\n\n    C++ signature :\n        void extend(std::vector<carla::rpc::BoneTransformDataOut, std::allocator<carla::rpc::BoneTransformDataOut> > {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "vector_of_gears": {
            "type": "class",
            "docstring": "",
            "methods": {
                "append": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "append( (vector_of_gears)arg1, (object)arg2) -> None :\n\n    C++ signature :\n        void append(std::vector<carla::rpc::GearPhysicsControl, std::allocator<carla::rpc::GearPhysicsControl> > {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "extend": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "extend( (vector_of_gears)arg1, (object)arg2) -> None :\n\n    C++ signature :\n        void extend(std::vector<carla::rpc::GearPhysicsControl, std::allocator<carla::rpc::GearPhysicsControl> > {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "vector_of_ints": {
            "type": "class",
            "docstring": "",
            "methods": {
                "append": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "append( (vector_of_ints)arg1, (object)arg2) -> None :\n\n    C++ signature :\n        void append(std::vector<int, std::allocator<int> > {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "extend": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "extend( (vector_of_ints)arg1, (object)arg2) -> None :\n\n    C++ signature :\n        void extend(std::vector<int, std::allocator<int> > {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "vector_of_transform": {
            "type": "class",
            "docstring": "",
            "methods": {
                "append": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "append( (vector_of_transform)arg1, (object)arg2) -> None :\n\n    C++ signature :\n        void append(std::vector<carla::geom::Transform, std::allocator<carla::geom::Transform> > {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "extend": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "extend( (vector_of_transform)arg1, (object)arg2) -> None :\n\n    C++ signature :\n        void extend(std::vector<carla::geom::Transform, std::allocator<carla::geom::Transform> > {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "vector_of_vector2D": {
            "type": "class",
            "docstring": "",
            "methods": {
                "append": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "append( (vector_of_vector2D)arg1, (object)arg2) -> None :\n\n    C++ signature :\n        void append(std::vector<carla::geom::Vector2D, std::allocator<carla::geom::Vector2D> > {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "extend": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "extend( (vector_of_vector2D)arg1, (object)arg2) -> None :\n\n    C++ signature :\n        void extend(std::vector<carla::geom::Vector2D, std::allocator<carla::geom::Vector2D> > {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        },
        "vector_of_wheels": {
            "type": "class",
            "docstring": "",
            "methods": {
                "append": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "append( (vector_of_wheels)arg1, (object)arg2) -> None :\n\n    C++ signature :\n        void append(std::vector<carla::rpc::WheelPhysicsControl, std::allocator<carla::rpc::WheelPhysicsControl> > {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                },
                "extend": {
                    "type": "method",
                    "signature": "built-in function",
                    "docstring": "extend( (vector_of_wheels)arg1, (object)arg2) -> None :\n\n    C++ signature :\n        void extend(std::vector<carla::rpc::WheelPhysicsControl, std::allocator<carla::rpc::WheelPhysicsControl> > {lvalue},boost::python::api::object)",
                    "is_builtin": true,
                    "is_static": false,
                    "is_class_method": false
                }
            },
            "properties": {},
            "attributes": {},
            "base_classes": [
                "instance"
            ],
            "source_file": "built-in"
        }
    } 
}